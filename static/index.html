<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV M3U Manager</title>
    <link rel="stylesheet" href="/static/index.css">
    <style>
        /* å¼¹çª—é€šçŸ¥æ ·å¼ */
        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: var(--bg-surface);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4 15px var(--shadow);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideUp 0.3s ease-out;
            min-width: 200px;
            justify-content: center;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.info {
            border-left: 4px solid var(--info);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>ğŸ“º IPTV M3U Manager</h1>
            <p>ç®¡ç†æ‚¨çš„ç›´æ’­è®¢é˜…ã€ç­›é€‰ã€ç”Ÿæˆä¸“å±åˆ—è¡¨</p>
        </header>

        <section id="created_outputs_section">
            <div class="glass-card">
                <h2>ğŸ”— å·²åˆ›å»ºèšåˆ</h2>
                <div id="output_list">æš‚æ— æ•°æ®</div>
            </div>
        </section>

        <section id="subscriptions">
            <div id="sub_form_container" class="glass-card">
                <h2 id="sub_form_title">â• æ·»åŠ è®¢é˜…æº</h2>

                <div class="tab-container">
                    <button id="tab_normal" class="tab-btn active" onclick="switchSubTab('normal')">
                        ğŸ”— æ™®é€šè®¢é˜…
                    </button>
                    <button id="tab_git" class="tab-btn" onclick="switchSubTab('git')">
                        ğŸ“¦ Git ä»“åº“
                    </button>
                </div>

                <input type="hidden" id="edit_sub_id">
                <input type="hidden" id="sub_is_enabled" value="true">
                <div class="form-group">
                    <input type="text" id="sub_name" placeholder="åç§° (ä¾‹å¦‚: å«è§†ç²¾å“)">
                </div>
                <div class="form-group">
                    <input type="text" id="sub_url" placeholder="M3U URL (å¤šä¸ªåœ°å€è¯·ç”¨è‹±æ–‡é€—å·éš”å¼€)">
                </div>
                <div class="form-group" id="ua_form_group">
                    <input type="text" id="sub_ua" list="ua_options" placeholder="User-Agent (å¯é€‰ï¼Œæ¨èé€‰æ‹©ä¸‹æ–¹å¸¸ç”¨ UA)" value="">
                    <datalist id="ua_options">
                        <option value="AptvPlayer/1.4.1">APTV (iOS/Apple TV) - æ¨è</option>
                        <option value="TiviMate/5.2.0 (Android 15)">TiviMate (Android TV) - æ¨è</option>
                        <option value="Mozilla/5.0">é»˜è®¤ (Browser)</option>
                        <option value="VLC/3.0.18">VLC Media Player</option>
                        <option value="PotPlayer/1.7">PotPlayer (Windows)</option>
                    </datalist>
                </div>
                <div class="form-group">
                    <select id="sub_auto_update"
                        style="width: 100%; padding: 12px; background: var(--input-bg); border: 1px solid var(--glass-border); color: var(--text); border-radius: 8px; outline: none;">
                        <option value="0">è‡ªåŠ¨æ›´æ–°: å…³é—­ (æ‰‹åŠ¨åˆ·æ–°)</option>
                        <option value="2">è‡ªåŠ¨æ›´æ–°: æ¯ 2 åˆ†é’Ÿ (æµ‹è¯•ç”¨)</option>
                        <option value="60">è‡ªåŠ¨æ›´æ–°: æ¯ 1 å°æ—¶</option>
                        <option value="720">è‡ªåŠ¨æ›´æ–°: æ¯ 12 å°æ—¶</option>
                        <option value="1440">è‡ªåŠ¨æ›´æ–°: æ¯ 24 å°æ—¶</option>
                        <option value="10080">è‡ªåŠ¨æ›´æ–°: æ¯ 7 å¤©</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="sub_btn" class="btn" onclick="addSubscription()">æ·»åŠ è®¢é˜…</button>
                    <button id="sub_cancel_btn" class="btn" style="display: none; background: rgba(255,255,255,0.1);"
                        onclick="cancelEditSub()">å–æ¶ˆä¿®æ”¹</button>
                </div>
            </div>

            <div class="glass-card">
                <h2>ğŸ“‹ å½“å‰è®¢é˜…</h2>
                <div id="sub_list">åŠ è½½ä¸­...</div>
            </div>
        </section>

        <section id="outputs">
            <div class="glass-card">
                <h2>ğŸ› ï¸ åˆ›å»ºèšåˆåˆ—è¡¨</h2>
                <div class="form-group">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">åç§°ä¸åç¼€</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="out_name" placeholder="èšåˆåç§° (ä¾‹å¦‚: å®¶åº­ç²¾é€‰)">
                        <input type="text" id="out_slug" placeholder="URL åç¼€ (ä¾‹å¦‚: family)">
                    </div>
                </div>

                <div class="form-group">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label
                            style="display: block; opacity: 0.9; margin: 0; font-size: 0.95em; font-weight: 500;">é€‰æ‹©è®¢é˜…æº
                            (å¤šé€‰)</label>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-sm" style="font-size: 0.8em; padding: 2px 8px;"
                                onclick="toggleAllSubs(1)">å…¨é€‰</button>
                            <button class="btn btn-sm" style="font-size: 0.8em; padding: 2px 8px;"
                                onclick="toggleAllSubs(0)">åé€‰</button>
                        </div>
                    </div>
                    <div id="sub_selector" class="sub-selector-list">æ­£åœ¨è·å–è®¢é˜…...</div>
                </div>

                <div class="form-group">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">é«˜çº§æ­£åˆ™
                        (å¯é€‰)</label>
                    <input type="text" id="out_regex" placeholder="CCTV.* (éä¸“ä¸šäººå£«å»ºè®®ç•™ç©º)" value=".*">
                </div>

                <div class="form-group">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">EPG
                        èŠ‚ç›®é¢„å‘Š (å¯é€‰)</label>
                    <input type="text" id="out_epg" placeholder="EPG XML é“¾æ¥ (ä¾‹å¦‚: http://epg.51zmt.top:8000/api/xml/)">
                </div>

                <div class="form-group" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="out_include_suffix" checked
                        style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                    <label for="out_include_suffix"
                        style="margin: 0; opacity: 0.9; font-size: 0.95em; font-weight: 500; cursor: pointer;">åœ¨é¢‘é“ååæ˜¾ç¤ºè®¢é˜…æº
                        (ä¾‹å¦‚: CCTV1 (å«è§†ç²¾å“))</label>
                </div>

                <div class="form-group" style="margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="out_is_enabled" checked
                            style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                        <label for="out_is_enabled"
                            style="margin: 0; opacity: 0.9; font-size: 0.95em; cursor: pointer; font-weight: 500;">å¯ç”¨è¯¥èšåˆæº</label>
                    </div>
                </div>

                <div class="form-group"
                    style="display: flex; gap: 12px; align-items: center; margin-bottom: 16px; background: var(--input-bg); padding: 10px; border-radius: 10px; border: 1px solid var(--glass-border);">
                    <div style="flex: 1;">
                        <select id="out_auto_update"
                            style="width: 100%; padding: 10px; background: transparent; border: 1px solid var(--glass-border); color: var(--text); border-radius: 8px; outline: none; font-size: 0.9em; cursor: pointer;">
                            <option value="0">è‡ªåŠ¨æ›´æ–°: å…³é—­ (æ‰‹åŠ¨åˆ·æ–°)</option>
                            <option value="2">è‡ªåŠ¨æ›´æ–°: æ¯ 2 åˆ†é’Ÿ (æµ‹è¯•ç”¨)</option>
                            <option value="60">è‡ªåŠ¨æ›´æ–°: æ¯ 1 å°æ—¶</option>
                            <option value="120">è‡ªåŠ¨æ›´æ–°: æ¯ 2 å°æ—¶</option>
                            <option value="240">è‡ªåŠ¨æ›´æ–°: æ¯ 4 å°æ—¶</option>
                            <option value="360">è‡ªåŠ¨æ›´æ–°: æ¯ 6 å°æ—¶</option>
                            <option value="480">è‡ªåŠ¨æ›´æ–°: æ¯ 8 å°æ—¶</option>
                            <option value="720">è‡ªåŠ¨æ›´æ–°: æ¯ 12 å°æ—¶</option>
                            <option value="1440">è‡ªåŠ¨æ›´æ–°: æ¯ 24 å°æ—¶</option>
                            <option value="10080">è‡ªåŠ¨æ›´æ–°: æ¯ 7 å¤©</option>
                        </select>
                    </div>
                    <div id="auto_visual_toggle_container"
                        style="flex: 1.2; display: flex; align-items: center; gap: 6px; padding-left: 10px; border-left: 1px solid var(--glass-border);">
                        <input type="checkbox" id="out_auto_visual"
                            style="width: 18px; height: 18px; cursor: pointer; margin: 0;">
                        <label for="out_auto_visual"
                            style="margin: 0; opacity: 0.8; font-size: 0.85em; cursor: pointer; line-height: 1.2;">æ›´æ–°åè‡ªåŠ¨æ‰§è¡Œæ·±åº¦æ£€æµ‹å¹¶å¯ç”¨/ç¦ç”¨é¢‘é“</label>
                    </div>
                </div>

                <div class="form-group" style="position: relative;">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">å…³é”®å­—ç­›é€‰
                        (å›è½¦æŸ¥çœ‹ä¸‹æ–¹é¢„è§ˆ)</label>
                    <div id="tag_container" class="tag-container">
                        <div style="display: flex; flex-grow: 1; align-items: center; gap: 5px;">
                            <input type="text" id="tag_input" placeholder="å…³é”®å­—"
                                style="background: transparent; border: none; outline: none; flex-grow: 2; padding: 0;">
                        </div>
                    </div>
                    <div id="preview_window" class="preview-float"></div>
                </div>
            </div>

            <input type="hidden" id="edit_output_id">
            <div style="display: flex; gap: 10px; margin-bottom: 16px;">
                <button id="out_btn" class="btn" style="width: 100%;" onclick="saveOutput()">ç”Ÿæˆä¸“å± M3U èšåˆ
                    URL</button>
                <button id="out_cancel_btn" class="btn" style="display: none; background: rgba(255,255,255,0.1);"
                    onclick="cancelEditOutput()">å–æ¶ˆä¿®æ”¹</button>
            </div>
    </div>

    </section>
    </div>


    <div id="channel_modal" class="modal" onclick="if(event.target == this) closePreview()">

        <button id="back-to-top" class="btn" onclick="scrollToTop()"
            style="background: var(--primary); border-radius: 50%; width: 50px; height: 50px; font-size: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; position: fixed; bottom: 30px; right: 30px; z-index: 2001;">â†‘</button>

        <div class="glass-card channel-modal-card">

            <div class="modal-header-toolbar">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 id="modal_title" style="margin: 0;">é¢‘é“é¢„è§ˆ</h2>
                    <span onclick="closePreview()"
                        style="cursor: pointer; font-size: 32px; line-height: 1; color: var(--text); opacity: 0.8;">&times;</span>
                </div>
                <!-- å·¥å…·æ  -->
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <div style="display: flex; gap: 5px; flex-grow: 1;">
                        <input type="text" id="channel_search" placeholder="ğŸ” æœç´¢é¢‘é“åç§°..."
                            oninput="debounceSearchChannels()"
                            style="width: 100%; padding: 0 12px; font-size: 0.9em; min-width: 150px; height: 36px;">
                    </div>



                    <div id="check_options_container"
                        style="display: none; align-items: center; gap: 5px; margin-right: 5px;">
                        <label
                            style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: var(--text); opacity: 0.9;">
                            <input type="checkbox" id="auto_disable_check" style="width: 16px; height: 16px;">
                            <span style="font-size: 0.9em;">æ ¹æ®ç»“æœè‡ªåŠ¨å¯ç”¨/ç¦ç”¨</span>
                        </label>
                    </div>
                    <button id="check_btn" class="btn btn-sm toolbar-btn" onclick="checkPageConnectivity()"
                        style="background: #8b5cf6; display: none;">ğŸš€ å¿«é€Ÿæ£€æµ‹</button>
                    <button id="check_visual_btn" class="btn btn-sm toolbar-btn" onclick="checkVisualConnectivity()"
                        style="background: #ec4899; display: none;">ğŸ“º æ·±åº¦æ£€æµ‹</button>
                    <button id="refresh_epg_btn" class="btn btn-sm toolbar-btn" onclick="refreshEPG()"
                        style="background: #10b981; display: none;">ğŸ”„ åˆ·æ–°èŠ‚ç›®è¡¨</button>

                    <!-- æ‰¹é‡é€‰æ‹©å’Œæ“ä½œ -->
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-sm toolbar-btn btn-primary" onclick="toggleSelectAll(true)"
                            id="sel_all_btn" style="display: none;">å…¨é€‰</button>
                        <button class="btn btn-sm toolbar-btn btn-primary" onclick="invertSelection()" id="sel_inv_btn"
                            style="display: none;">åé€‰</button>
                        <button class="btn btn-sm toolbar-btn btn-success-soft" onclick="selectByStatus(true)"
                            style="display: none;" id="sel_enabled_btn">å…¨é€‰å¯ç”¨</button>
                        <button class="btn btn-sm toolbar-btn btn-danger-soft" onclick="selectByStatus(false)"
                            style="display: none;" id="sel_disabled_btn">å…¨é€‰ç¦ç”¨</button>
                    </div>


                    <button class="btn btn-sm toolbar-btn" onclick="batchSetStatus(true)"
                        style="background: #059669; display: none;" id="batch_enable_btn">å¯ç”¨é€‰ä¸­</button>
                    <button class="btn btn-sm toolbar-btn" onclick="batchSetStatus(false)"
                        style="background: #b91c1c; display: none;" id="batch_disable_btn">ç¦ç”¨é€‰ä¸­</button>
                </div>
            </div>

            <!-- æ»šåŠ¨ä¸»ä½“ -->
            <div id="channel_list_container" onscroll="handleModalScroll(this)"
                style="padding: 0 24px 24px; overflow-y: auto; flex-grow: 1;">
                <div id="channel_list">åŠ è½½ä¸­...</div>
            </div>

            <div class="modal-footer-stats">
                <div id="preview_stats" style="font-size: 0.9em; opacity: 0.8;">
                    å…± 0 ä¸ªé¢‘é“ / å·²å¯ç”¨ 0 ä¸ª
                </div>
                <button class="btn" onclick="closePreview()" style="background: rgba(255,255,255,0.1);">å…³é—­é¢„è§ˆ</button>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <!-- ä»»åŠ¡ä¸­å¿ƒæŒ‚è½½ç‚¹ -->
    <div class="navbar-tools">
        <div class="task-toggle-btn" onclick="taskCenter.toggle()" title="æŸ¥çœ‹ä»»åŠ¡ä¸­å¿ƒ">
            <span id="task_icon">ğŸ””</span>
            <div id="task_badge" class="task-count-badge" style="display: none;">0</div>
        </div>
    </div>

    <!-- æ§åˆ¶å°æ—¥å¿—é¢æ¿ -->
    <div id="console_panel" class="console-panel">
        <div class="console-header">
            <h3>ğŸ–¥ï¸ ç³»ç»Ÿæ§åˆ¶å°</h3>
            <div style="display: flex; gap: 8px;">
                <button class="btn btn-sm" onclick="clearConsole()"
                    style="background: rgba(255,255,255,0.1); font-size: 0.8em;">æ¸…ç©º</button>
                <button class="btn btn-sm" onclick="toggleConsole()"
                    style="background:transparent; font-size: 1.25em; opacity: 0.7; padding:0 5px;">&times;</button>
            </div>
        </div>
        <div id="console_output" class="console-output">
            <div style="color: #6366f1; opacity: 0.8; font-family: monospace;">[System] æ­£åœ¨ç­‰å¾…å®æ—¶æ—¥å¿—æµ...</div>
        </div>
    </div>

    <!-- ä»»åŠ¡ä¸­å¿ƒé¢æ¿ -->
    <div id="task_panel" class="task-panel">
        <div class="task-panel-header">
            <h3>ä»»åŠ¡ä¸­å¿ƒ</h3>
            <div style="display: flex; gap: 8px; align-items:center;">
                <button class="btn btn-sm" onclick="toggleTheme()" id="theme_toggle_btn"
                    style="background: var(--bg-card); color: var(--text); border: 1px solid var(--glass-border); font-size: 0.9em; padding: 2px 8px; font-weight: bold; margin-right: 4px;">
                    ğŸŒ æ—¥é—´æ¨¡å¼
                </button>
                <button class="btn btn-sm" onclick="restartServiceJS()"
                    style="background: var(--danger); font-size: 0.75em; padding: 2px 8px; font-weight: bold; box-shadow: 0 0 10px rgba(239, 68, 68, 0.4);">
                    ğŸš¨ é‡å¯æœåŠ¡
                </button>
                <button class="btn btn-sm" onclick="taskCenter.toggle()"
                    style="background:transparent; font-size: 1.2em; opacity: 0.7; border:none; padding:0 5px;">&times;</button>
            </div>
        </div>
        <div id="task_list_container" class="task-list-container">
            <div class="empty-task-state">æš‚æ— ä»»åŠ¡è®°å½•</div>
        </div>
        <div class="task-panel-footer">
            <button class="btn btn-sm btn-outline" style="flex: 1;" onclick="taskCenter.loadTasks()">ğŸ”„ åˆ·æ–°åˆ—è¡¨</button>
            <button class="btn btn-sm btn-danger-outline" style="flex: 1;" onclick="taskCenter.cleanupTasks()">ğŸ§¹
                æ¸…ç†å†å²</button>
            <button class="btn btn-sm" style="flex: 1; background: var(--primary); color: #fff;"
                onclick="toggleConsole()">ğŸ–¥ï¸ æ§åˆ¶å°</button>
        </div>
    </div>

    <script>
        window.previewDebounceTimer = null;
        window.searchDebounceTimer = null;
        let currentSubTab = 'normal';

        // --- ä¸»é¢˜åˆ‡æ¢é€»è¾‘ ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const btn = document.getElementById('theme_toggle_btn');
            if (savedTheme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
                if (btn) btn.innerText = 'ğŸŒ™ æ·±è‰²æ¨¡å¼';
            } else {
                document.documentElement.removeAttribute('data-theme');
                if (btn) btn.innerText = 'ğŸŒ æ—¥é—´æ¨¡å¼';
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const btn = document.getElementById('theme_toggle_btn');

            if (currentTheme === 'light') {
                // åˆ‡æ¢åˆ°æ·±è‰² (é»˜è®¤)
                document.documentElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'dark');
                if (btn) btn.innerText = 'ğŸŒ æ—¥é—´æ¨¡å¼';
                showToast('å·²åˆ‡æ¢è‡³æ·±è‰²æ¨¡å¼', 'info');
            } else {
                // åˆ‡æ¢åˆ°äº®è‰²
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
                if (btn) btn.innerText = 'ğŸŒ™ æ·±è‰²æ¨¡å¼';
                showToast('å·²åˆ‡æ¢è‡³æ—¥é—´æ¨¡å¼', 'info');
            }
        }

        // ç«‹å³åˆå§‹åŒ–ä¸»é¢˜
        initTheme();

        // ==========================================
        // æ ¸å¿ƒä»»åŠ¡ä¸­å¿ƒæ§åˆ¶å¼•æ“ (NAS Style)
        // ==========================================
        class GlobalTaskCenter {
            constructor() {
                this.tasks = new Map();
                this.isVisible = false;
                this.ws = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                this.loadTasks();
                this.connectWS();
                this.initialized = true;
                this.updateBadge();
            }

            toggle() {
                const panel = document.getElementById('task_panel');
                this.isVisible = !this.isVisible;
                if (this.isVisible) {
                    panel.classList.add('active');
                    this.loadTasks(); // å±•å¼€æ—¶åˆ·æ–°
                } else {
                    panel.classList.remove('active');
                }
            }

            async loadTasks() {
                try {
                    const res = await fetch('/api/tasks/');
                    const data = await res.json();
                    data.forEach(task => this.tasks.set(task.id, task));
                    this.render();
                    this.updateBadge();
                } catch (e) {
                    console.error("Failed to load tasks", e);
                }
            }

            connectWS() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/tasks/ws`;

                this.ws = new WebSocket(wsUrl);

                this.ws.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        if (msg.type === 'task_update') {
                            this.handleUpdate(msg.data);
                        } else if (msg.type === 'console_log') {
                            this.handleConsoleLog(msg);
                        }
                    } catch (e) { console.error("WS Message Error", e); }
                };

                this.ws.onclose = () => {
                    console.log("Task WS Closed. Reconnecting...");
                    setTimeout(() => this.connectWS(), 3000);
                };
            }

            handleConsoleLog(msg) {
                const output = document.getElementById('console_output');
                if (!output) return;

                const line = document.createElement('div');
                line.className = 'console-line';
                line.innerHTML = `<span class="log-time">[${msg.timestamp}]</span> <span class="log-content">${this.escapeHTML(msg.line)}</span>`;
                output.appendChild(line);

                // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€ä¸‹æ–¹
                output.scrollTop = output.scrollHeight;

                // é™åˆ¶è¡Œæ•° (300è¡Œ) é˜²æ­¢å†…å­˜æº¢å‡º
                while (output.childNodes.length > 300) {
                    output.removeChild(output.firstChild);
                }
            }

            escapeHTML(str) {
                const p = document.createElement('p');
                p.textContent = str;
                return p.innerHTML;
            }

            handleUpdate(task) {
                const oldTask = this.tasks.get(task.id);
                const isStatusChange = oldTask && oldTask.status !== task.status;

                // å¦‚æœä»»åŠ¡ä¸å­˜åœ¨æˆ–è€…çŠ¶æ€/è¿›åº¦æœ‰å˜ï¼Œåˆ™æ›´æ–°
                this.tasks.set(task.id, { ...oldTask, ...task });
                this.render();
                this.updateBadge();

                // é‡ç‚¹ï¼šä»»åŠ¡çŠ¶æ€å˜ä¸ºç»ˆæ€æ—¶çš„å¼ºæé†’
                if (isStatusChange) {
                    if (task.status === 'success') {
                        showToast(`ä»»åŠ¡æˆåŠŸ: ${task.name}`, "success");
                    } else if (task.status === 'failure') {
                        showToast(`ä»»åŠ¡å¤±è´¥: ${task.name}`, "error");
                    } else if (task.status === 'canceled') {
                        showToast(`ä»»åŠ¡å·²ä¸­æ­¢: ${task.name}`, "info");
                    }
                }

                // å¤„ç†è‡ªåŠ¨æ›´æ–°å®Œæˆåçš„åˆ·æ–°é€»è¾‘ (å¦‚æœæ˜¯æˆåŠŸçš„å…³é”®ä»»åŠ¡)
                if (task.status === 'success' && (task.id.startsWith('auto-') || task.id.startsWith('fetch-') || task.id.startsWith('check-'))) {
                    // å»¶è¿Ÿåˆ·æ–°ä¸»åˆ—è¡¨ï¼Œç¡®ä¿åç«¯æ•°æ®åº“å·²æŒä¹…åŒ–
                    setTimeout(() => {
                        fetchSubs(true);
                        fetchOutputs(true);
                        // å¦‚æœå½“å‰å¼€ç€é¢„è§ˆæ¡†ï¼Œå°è¯•å±€éƒ¨åˆ·æ–°é¢„è§ˆæ•°æ®
                        if (typeof searchChannels === 'function' && document.getElementById('channel_modal').style.display === 'flex') {
                            searchChannels();
                        }
                    }, 1000);
                }
            }

            async stopTask(taskId) {
                if (!confirm("ç¡®å®šè¦ä¸­æ­¢è¯¥ä»»åŠ¡å—ï¼Ÿ")) return;
                try {
                    const res = await fetch(`/api/tasks/${taskId}/stop`, { method: 'POST' });
                    const result = await res.json();
                    if (result.status === 'success') {
                        showToast("ä¸­æ­¢ä¿¡å·å·²å‘é€", "info");
                    } else {
                        showToast(result.message, "error");
                    }
                } catch (e) {
                    showToast("æ“ä½œå¤±è´¥", "error");
                }
            }

            async cleanupTasks() {
                if (!confirm("ç¡®å®šè¦æ¸…ç†æ‰€æœ‰å·²å®Œæˆçš„ä»»åŠ¡è®°å½•å—ï¼Ÿ\n(è¿è¡Œä¸­çš„ä»»åŠ¡å°†è¢«ä¿ç•™)")) return;
                try {
                    const res = await fetch('/api/tasks/cleanup', { method: 'DELETE' });
                    const result = await res.json();
                    if (result.status === 'success') {
                        showToast(result.message, "success");
                        // å±€éƒ¨æ¸…ç†æœ¬åœ°ç¼“å­˜å¹¶é‡æ–°æ¸²æŸ“
                        for (const [id, task] of this.tasks.entries()) {
                            if (['success', 'failure', 'canceled'].includes(task.status)) {
                                this.tasks.delete(id);
                            }
                        }
                        this.render();
                        this.updateBadge();
                    }
                } catch (e) {
                    showToast("æ¸…ç†å¤±è´¥", "error");
                }
            }

            updateBadge() {
                const badge = document.getElementById('task_badge');
                const runningCount = Array.from(this.tasks.values()).filter(t => t.status === 'running' || t.status === 'pending').length;

                if (runningCount > 0) {
                    badge.innerText = runningCount;
                    badge.style.display = 'flex';
                    document.getElementById('task_icon').innerHTML = 'âš™ï¸';
                    document.getElementById('task_icon').classList.add('icon-spin');
                } else {
                    badge.style.display = 'none';
                    document.getElementById('task_icon').innerHTML = 'ğŸ””';
                    document.getElementById('task_icon').classList.remove('icon-spin');
                }
            }

            render() {
                const container = document.getElementById('task_list_container');
                if (this.tasks.size === 0) {
                    container.innerHTML = '<div class="empty-task-state">æš‚æ— ä»»åŠ¡è®°å½•</div>';
                    return;
                }

                // æŒ‰æ›´æ–°æ—¶é—´é™åºæ’åˆ—
                const sortedTasks = Array.from(this.tasks.values())
                    .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
                    .slice(0, 30); // ä»…æ˜¾ç¤ºæœ€è¿‘30ä¸ª

                container.innerHTML = sortedTasks.map(task => {
                    const progress = task.progress || 0;
                    const statusClass = task.status;
                    const canStop = task.status === 'running' || task.status === 'pending';

                    let statusText = '';
                    switch (task.status) {
                        case 'pending': statusText = 'â³ ç­‰å¾…ä¸­...'; break;
                        case 'running': statusText = `ğŸš€ æ­£åœ¨è¿è¡Œ (${progress}%)`; break;
                        case 'success': statusText = 'âœ… ä»»åŠ¡å®Œæˆ'; break;
                        case 'failure': statusText = 'âŒ æ‰§è¡Œå¤±è´¥'; break;
                        case 'canceled': statusText = 'ğŸ›‘ å·²ä¸­æ­¢'; break;
                    }

                    return `
                        <div class="task-card" id="task_card_${task.id}">
                            <div class="task-info-row">
                                <div class="task-main-info">
                                    <div class="task-name">${task.name}</div>
                                    <div class="task-sub-info">
                                        <span>${formatDate(task.updated_at).split(' ')[1]}</span>
                                        <span style="opacity: 0.8">${task.message || ''}</span>
                                    </div>
                                </div>
                                <div class="task-actions">
                                    ${canStop ? `<button class="task-stop-btn" onclick="taskCenter.stopTask('${task.id}')">ä¸­æ­¢</button>` : ''}
                                </div>
                            </div>
                            <div class="task-progress-wrapper">
                                <div class="task-progress-bar ${statusClass}" style="width: ${progress}%"></div>
                            </div>
                            <div class="task-status-text ${statusClass}">${statusText}</div>
                        </div>
                    `;
                }).join('');
            }
        }

        const taskCenter = new GlobalTaskCenter();
        document.addEventListener('DOMContentLoaded', () => {
            taskCenter.init();
            makeDraggable(document.getElementById('console_panel'), document.querySelector('.console-header'));
        });

        function makeDraggable(element, handle) {
            if (!element || !handle) return;
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            handle.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                element.style.transition = 'none'; // æ‹–åŠ¨æ—¶ç¦ç”¨åŠ¨ç”»
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
                element.style.bottom = 'auto'; // æ¸…é™¤åŸæœ‰å¯¹é½
                element.style.right = 'auto';
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
                element.style.transition = 'all 0.3s cubic-bezier(0.19, 1, 0.22, 1)'; // æ¢å¤åŠ¨ç”»
            }
        }

        function toggleConsole() {
            const panel = document.getElementById('console_panel');
            panel.classList.toggle('active');
        }

        async function restartServiceJS() {
            if (!confirm("ğŸš¨ è­¦å‘Šï¼šæ­¤æ“ä½œå°†å¼ºåˆ¶é‡å¯åç«¯æœåŠ¡è¿›ç¨‹ï¼\n\nè¿™é€šå¸¸ç”¨äºè§£å†³ä»»åŠ¡å½»åº•å‡æ­»ä¸”æ— æ³•ä¸­æ­¢çš„æƒ…å†µã€‚\né‡å¯æœŸé—´æ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡å°†ä¸­æ–­ã€‚\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ")) return;

            try {
                showToast("æ­£åœ¨å‘é€é‡å¯æŒ‡ä»¤...", "info");
                const res = await fetch('/api/system/restart', { method: 'POST' });
                const result = await res.json();

                if (result.status === 'success') {
                    // æ˜¾ç¤ºå…¨å±é”å®šé®ç½©
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; backdrop-filter:blur(10px);';
                    overlay.innerHTML = `
                        <div style="font-size: 3em; margin-bottom: 20px;">ğŸ”„</div>
                        <h2 style="color:white; margin:0;">æ­£åœ¨é‡å¯æœåŠ¡...</h2>
                        <p style="opacity:0.7; margin-top:10px;">è¯·ç¨åï¼Œç³»ç»Ÿæ­£åœ¨å°è¯•è‡ªåŠ¨é‡æ–°è¿æ¥</p>
                        <div style="margin-top:20px; width:200px; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">
                            <div id="restart_progress" style="width:0%; height:100%; background:#6366f1; transition:width 5s linear;"></div>
                        </div>
                    `;
                    document.body.appendChild(overlay);

                    // å¯åŠ¨è¿›åº¦æ¡åŠ¨ç”»
                    setTimeout(() => {
                        const bar = document.getElementById('restart_progress');
                        if (bar) bar.style.width = '100%';
                    }, 100);

                    // 5ç§’åå°è¯•åˆ·æ–°é¡µé¢
                    setTimeout(() => {
                        window.location.reload();
                    }, 5500);
                } else {
                    showToast(result.message, "error");
                }
            } catch (e) {
                showToast("é‡å¯æŒ‡ä»¤ç”±äºè¿æ¥ä¸­æ–­æ— æ³•ç¡®è®¤ï¼Œè¯·5ç§’åæ‰‹åŠ¨åˆ·æ–°é¡µé¢", "warning");
                // åŒæ ·æ‰§è¡Œåˆ·æ–°é€»è¾‘
                setTimeout(() => window.location.reload(), 5000);
            }
        }

        function clearConsole() {
            const output = document.getElementById('console_output');
            output.innerHTML = '<div style="color: #6366f1; opacity: 0.5; font-family: monospace;">[System] æ§åˆ¶å°å·²æ¸…ç©º</div>';
        }

        function switchSubTab(mode) {
            currentSubTab = mode;
            const tabNormal = document.getElementById('tab_normal');
            const tabGit = document.getElementById('tab_git');
            const uaGroup = document.getElementById('ua_form_group');
            const urlInput = document.getElementById('sub_url');

            if (mode === 'normal') {
                tabNormal.classList.add('active');
                tabGit.classList.remove('active');
                uaGroup.style.display = 'block';
                urlInput.placeholder = "M3U URL (å¤šä¸ªåœ°å€è¯·ç”¨è‹±æ–‡é€—å·éš”å¼€)";
            } else {
                tabGit.classList.add('active');
                tabNormal.classList.remove('active');
                uaGroup.style.display = 'none';
                urlInput.placeholder = "Git ä»“åº“ URL (ä¾‹å¦‚: https://github.com/YueChan/Live.git)";
            }
        }

        function debounceUpdatePreview() {
            clearTimeout(window.previewDebounceTimer);
            window.previewDebounceTimer = setTimeout(updateRealtimePreview, 300);
        }

        function debounceSearchChannels() {
            clearTimeout(window.searchDebounceTimer);
            window.searchDebounceTimer = setTimeout(searchChannels, 300);
        }

        function formatDate(isoStr) {
            if (!isoStr) return 'ä»æœªæ›´æ–°';
            // ç¡®ä¿å…¼å®¹æ€§ï¼šå°† "2024-01-01 12:00:00" è½¬ä¸º "2024-01-01T12:00:00Z"
            let dateStr = isoStr.replace(' ', 'T');
            if (!dateStr.endsWith('Z')) dateStr += 'Z';
            const d = new Date(dateStr);
            return d.toLocaleString('zh-CN', { hour12: false });
        }

        // ... (fetchSubs æ²¡å˜) ...

        let currentChannels = [];
        let filteredChannels = [];
        let renderOffset = 0;
        const RENDER_SIZE = 100;

        // å¤šé€‰çŠ¶æ€
        window.selectedChannelIds = new Set();

        function prepareModal(titleText, showCheckBtn = false) {
            const modal = document.getElementById('channel_modal');
            const title = document.getElementById('modal_title');
            const list = document.getElementById('channel_list');
            const container = document.getElementById('channel_list_container');
            const searchInput = document.getElementById('channel_search');

            // åˆ‡æ¢æ£€æµ‹æŒ‰é’®
            const checkBtn = document.getElementById('check_btn');
            const checkVisualBtn = document.getElementById('check_visual_btn');
            const checkOptions = document.getElementById('check_options_container');
            const refreshBtn = document.getElementById('refresh_epg_btn');

            // æ‰¹é‡æŒ‰é’®
            const selAllBtn = document.getElementById('sel_all_btn');
            const selInvBtn = document.getElementById('sel_inv_btn');
            const selEnBtn = document.getElementById('sel_enabled_btn');
            const selDisBtn = document.getElementById('sel_disabled_btn');
            const batchEnBtn = document.getElementById('batch_enable_btn');
            const batchDisBtn = document.getElementById('batch_disable_btn');
            const batchSep = document.getElementById('batch_sep');

            const displayStyle = showCheckBtn ? 'block' : 'none';
            if (checkBtn) checkBtn.style.display = displayStyle;
            if (checkVisualBtn) checkVisualBtn.style.display = displayStyle;
            if (checkOptions) checkOptions.style.display = showCheckBtn ? 'flex' : 'none';
            if (refreshBtn) refreshBtn.style.display = displayStyle;

            if (selAllBtn) selAllBtn.style.display = displayStyle;
            if (selInvBtn) selInvBtn.style.display = displayStyle;
            if (selEnBtn) selEnBtn.style.display = displayStyle;
            if (selDisBtn) selDisBtn.style.display = displayStyle;
            if (batchEnBtn) batchEnBtn.style.display = displayStyle;
            if (batchDisBtn) batchDisBtn.style.display = displayStyle;
            if (batchSep) batchSep.style.display = displayStyle;

            title.innerText = titleText;
            list.innerHTML = 'æ­£åœ¨åŠ è½½...';
            searchInput.value = ''; // é‡ç½®æœç´¢

            // åˆ·æ–°èŠ‚ç›®è¡¨æŒ‰é’®
            const refreshEpgBtn = document.getElementById('refresh_epg_btn');
            if (refreshEpgBtn) {
                refreshEpgBtn.style.display = (showCheckBtn && window.currentEPGUrl) ? 'block' : 'none';
            }

            modal.style.setProperty('display', 'flex', 'important');
            document.body.style.overflow = 'hidden';
            container.scrollTop = 0;
            renderOffset = 0;
            window.selectedChannelIds.clear(); // é‡ç½®é€‰æ‹©
        }

        async function viewChannels(id, name, epgUrl = null) {
            window.currentEPGUrl = null; // å•ä¸ªæŸ¥çœ‹å¿½ç•¥è®¢é˜… EPG
            prepareModal(`é¢„è§ˆ: ${name}`);
            try {
                const res = await fetch(`/subscriptions/${id}/channels`);
                const data = await res.json();
                // æ‰‹åŠ¨æ·»åŠ æ¥æº
                currentChannels = data.map(c => ({ ...c, source: name }));
                filteredChannels = currentChannels;
                renderBaseTable(document.getElementById('channel_list'));
            } catch (err) {
                document.getElementById('channel_list').innerHTML = 'åŠ è½½å¤±è´¥: ' + err.message;
            }
        }

        async function viewOutputPreview(slug, name) {
            window.currentEPGUrl = null;

            // ä»å…¨å±€ allOutputs æ‰¾é…ç½®
            const out = allOutputs.find(o => o.slug === slug);
            if (out) window.currentEPGUrl = out.epg_url;

            prepareModal(`é¢„è§ˆèšåˆ: ${name}`, true); // ä¼  true æ˜¾ç¤ºæ£€æµ‹æŒ‰é’®

            if (!out) {
                document.getElementById('channel_list').innerHTML = 'æ— æ³•æ‰¾åˆ°èšåˆé…ç½®ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
                return;
            }

            try {
                // è§£æé…ç½®
                let keywords = [];
                try {
                    const parsed = JSON.parse(out.keywords || "[]");
                    parsed.forEach(k => {
                        if (typeof k === 'string') keywords.push({ value: k, group: '' });
                        else keywords.push(k);
                    });
                } catch (e) { }

                const subIds = JSON.parse(out.subscription_ids || "[]");

                const payload = {
                    subscription_ids: subIds,
                    keywords: keywords,
                    filter_regex: out.filter_regex
                };

                const res = await fetch('/outputs/preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await res.json();

                // æŠŠç»“æœé“ºå¹³å¹¶å»é‡ï¼ˆé¿å…ä¸€ä¸ªé¢‘é“åŒ¹é…å¤šä¸ªå…³é”®å­—å¯¼è‡´å¤šæ¬¡å‡ºç°ï¼‰
                const seenIds = new Set();
                let flatChannels = [];
                for (const [key, list] of Object.entries(data)) {
                    list.forEach(c => {
                        if (!seenIds.has(c.id)) {
                            seenIds.add(c.id);
                            flatChannels.push(c);
                        }
                    });
                }

                currentChannels = flatChannels;
                filteredChannels = flatChannels;
                renderBaseTable(document.getElementById('channel_list'), true);
            } catch (err) {
                document.getElementById('channel_list').innerHTML = 'é¢„è§ˆåŠ è½½å¤±è´¥: ' + err.message;
            }
        }

        function searchChannels() {
            const query = document.getElementById('channel_search').value.toLowerCase().trim();
            if (!query) {
                filteredChannels = currentChannels;
            } else {
                filteredChannels = currentChannels.filter(c => c.name.toLowerCase().includes(query) || c.group.toLowerCase().includes(query));
            }
            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);
        }

        function renderBaseTable(list, showActions = false) {
            window.lastRenderShowActions = showActions; // è®°å½•çŠ¶æ€ï¼Œæ–¹ä¾¿é‡ç»˜
            if (filteredChannels.length === 0) {
                list.innerHTML = '<p style="text-align:center; padding: 20px;">æš‚æ— åŒ¹é…å†…å®¹</p>';
                return;
            }

            // ç§»åŠ¨ç«¯èšåˆé¢„è§ˆæ¨¡å¼ï¼šä½¿ç”¨æ–°çš„å¡ç‰‡å¸ƒå±€
            const isMobile = window.innerWidth <= 768;
            if (isMobile && showActions) {
                list.innerHTML = `
                    <div id="channel_cards_container"></div>
                    <div id="load_more_container" style="text-align: center; padding: 20px;">
                        <button class="btn" style="min-width: 200px;" onclick="renderNextBatch()">æŸ¥çœ‹æ›´å¤š (å‰©ä½™ ${filteredChannels.length} æ¡)</button>
                    </div>
                `;
                renderNextBatch();
                updatePreviewStats();
                return;
            }

            // æ¡Œé¢ç«¯åŠéèšåˆé¢„è§ˆæ¨¡å¼ï¼šä½¿ç”¨ä¼ ç»Ÿè¡¨æ ¼å¸ƒå±€
            list.innerHTML = `
                <table class="channel-table-container" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                    <thead>
                        <tr style="text-align: left; border-bottom: 2px solid var(--primary);">
                            ${showActions ? '<th style="padding: 10px; width: 30px;"><input type="checkbox" id="master_checkbox" onclick="toggleSelectAll(this.checked)"></th>' : ''}
                            <th style="padding: 10px; width: 60px;">Logo</th>
                            <th style="padding: 10px;">åç§°</th>
                            <th style="padding: 10px;">tvg-id</th>
                            ${window.currentEPGUrl ? '<th style="padding: 10px;">å½“å‰èŠ‚ç›®</th>' : ''}
                            <th style="padding: 10px;">åˆ†ç»„</th>
                            ${showActions ? '<th style="padding: 10px;">æ¥æº</th>' : ''}
                            ${showActions ? '<th style="padding: 10px; width: 100px;">å¯ç”¨æ€§</th>' : ''}
                            ${showActions ? '<th style="padding: 10px; width: 80px;">é¢„è§ˆ</th>' : ''}
                            ${showActions ? '<th style="padding: 10px; width: 80px;">æ“ä½œ</th>' : ''}
                        </tr>
                    </thead>
                    <tbody id="channel_tbody"></tbody>
                </table>
                <div id="load_more_container" style="text-align: center; padding: 20px;">
                    <button class="btn" style="min-width: 200px;" onclick="renderNextBatch()">æŸ¥çœ‹æ›´å¤š (å‰©ä½™ ${filteredChannels.length} æ¡)</button>
                </div>
            `;
            renderNextBatch();
            updatePreviewStats();
        }



        function renderNextBatch() {
            const isMobile = window.innerWidth <= 768;
            const isMobileCardMode = isMobile && window.lastRenderShowActions;

            // æ ¹æ®æ¨¡å¼é€‰æ‹©ç›®æ ‡å®¹å™¨
            const list = isMobileCardMode
                ? document.getElementById('channel_cards_container')
                : document.getElementById('channel_tbody');

            if (!list) return;

            const end = Math.min(renderOffset + RENDER_SIZE, filteredChannels.length);
            const batch = filteredChannels.slice(renderOffset, end);

            let html = '';

            if (isMobileCardMode) {
                // ç§»åŠ¨ç«¯èšåˆé¢„è§ˆæ¨¡å¼ï¼šæ¸²æŸ“æ–°çš„åŒå±‚å¡ç‰‡
                html = batch.map((c, idx) => {
                    const image = c.visualImage || c.check_image;
                    const isSelected = window.selectedChannelIds.has(c.id);
                    const isDisabled = c.is_enabled === false;

                    // çŠ¶æ€æ–‡å­—
                    let statusText = '-';
                    if (c.status !== undefined) {
                        statusText = c.status ? `âœ… ${c.latency}ms` : `âŒ å¤±è´¥`;
                    } else if (c.checking) {
                        statusText = 'â³ æ£€æµ‹ä¸­...';
                    }

                    // ä¸Šæ¬¡æ£€æµ‹æ—¶é—´
                    let checkTimeHtml = '';
                    if (c.check_date) {
                        let dateStr = c.check_date.replace(' ', 'T');
                        if (!dateStr.endsWith('Z')) dateStr += 'Z';
                        const dateObj = new Date(dateStr);
                        const now = new Date();
                        const mins = Math.floor((now - dateObj) / 60000);
                        let timeStr = mins < 60 ? `${mins}åˆ†å‰` : (mins < 1440 ? `${Math.floor(mins / 60)}æ—¶å‰` : `${Math.floor(mins / 1440)}å¤©å‰`);
                        const hhmm = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                        const isAuto = c.check_source === 'auto';
                        const autoTag = isAuto ? '<span style="background: rgba(251,191,36,0.15); color: #fbbf24; padding: 1px 4px; border-radius: 3px; font-size: 0.8em; margin-left: 4px;">è‡ªåŠ¨</span>' : '';
                        checkTimeHtml = `<div class="mobile-channel-card__check-time">ä¸Šæ¬¡æ£€æµ‹: ${timeStr} (${hhmm}) ${autoTag}</div>`;
                    }

                    // EPG èŠ‚ç›®ï¼ˆå¼‚æ­¥åŠ è½½ï¼Œå…ˆæ˜¾ç¤ºå ä½ï¼‰
                    const epgCellId = `mobile_epg_${renderOffset}_${idx}`;

                    return `
                    <div class="mobile-channel-card ${isDisabled ? 'disabled' : ''} ${isSelected ? 'selected' : ''}" 
                         data-id="${c.id}" onclick="handleMobileCardClick(event, ${c.id})">
                        <!-- Logo æ”¾åœ¨å¤§å¡ç‰‡å³ä¸Šè§’ -->
                        ${c.logo ? `<img class="mobile-channel-card__logo" src="${c.logo}" onerror="this.style.display='none'" alt="Logo">` : ''}
                        <!-- èƒŒæ™¯é¢„è§ˆå›¾ -->
                        <div class="mobile-channel-card__bg ${!image ? 'mobile-channel-card__bg--empty' : ''}">
                            ${image
                            ? `<img src="${image}" onclick="event.stopPropagation(); showLightbox('${image}')" alt="é¢„è§ˆ">`
                            : '<span>ğŸ“º</span>'}
                        </div>
                        <!-- æ¯›ç»ç’ƒä¿¡æ¯å¡ç‰‡ -->
                        <div class="mobile-channel-card__info">
                            
                            <div class="mobile-channel-card__row">
                                <span class="mobile-channel-card__label">åç§°:</span>
                                <span class="mobile-channel-card__value"><strong>${c.name}</strong></span>
                            </div>
                            
                            <div class="mobile-channel-card__row">
                                <span class="mobile-channel-card__label">TVG:</span>
                                <span class="mobile-channel-card__value">${c.tvg_id || '-'}</span>
                            </div>
                            
                            ${window.currentEPGUrl ? `
                            <div class="mobile-channel-card__row">
                                <span class="mobile-channel-card__label">èŠ‚ç›®:</span>
                                <span class="mobile-channel-card__value" id="${epgCellId}">
                                    <span class="mobile-channel-card__epg-tag mobile-channel-card__epg-tag--empty">åŠ è½½ä¸­...</span>
                                </span>
                            </div>` : ''}
                            
                            <div class="mobile-channel-card__row">
                                <span class="mobile-channel-card__label">åˆ†ç»„:</span>
                                <span class="mobile-channel-card__value"><strong>${c.group || 'é»˜è®¤'}</strong></span>
                            </div>
                            
                            <div class="mobile-channel-card__row">
                                <span class="mobile-channel-card__label">æ¥æº:</span>
                                <span class="mobile-channel-card__value">${c.source || 'æœªçŸ¥'}</span>
                            </div>
                            
                            <div class="mobile-channel-card__row">
                                <span class="mobile-channel-card__label">çŠ¶æ€:</span>
                                <span class="mobile-channel-card__value">${statusText}</span>
                            </div>
                            
                            ${checkTimeHtml}
                            
                            <!-- åº•éƒ¨æ“ä½œæ  -->
                            <div class="mobile-channel-card__actions">
                                <label class="mobile-channel-card__checkbox">
                                    <input type="checkbox" class="ch-checkbox" data-id="${c.id}" 
                                           ${isSelected ? 'checked' : ''} 
                                           onchange="event.stopPropagation(); toggleChannelSelection(${c.id}, this.checked); updateMobileCardSelection(${c.id}, this.checked);">
                                </label>
                                <button class="mobile-channel-card__toggle-btn ${isDisabled ? 'mobile-channel-card__toggle-btn--enable' : 'mobile-channel-card__toggle-btn--disable'}"
                                        onclick="event.stopPropagation(); toggleChannel(${c.id})">
                                    ${isDisabled ? 'å¯ç”¨' : 'ç¦ç”¨'}
                                </button>
                            </div>
                        </div>
                    </div>
                    `;
                }).join('');
            } else {
                // æ¡Œé¢ç«¯ï¼šä¿æŒåŸæœ‰è¡¨æ ¼æ¸²æŸ“é€»è¾‘
                html = batch.map(c => {
                    let statusHtml = '<span style="opacity: 0.3;">-</span>';
                    if (c.status !== undefined) {
                        if (c.status) {
                            statusHtml = `<span style="color: #10b981; font-size: 0.85em;">âœ… ${c.latency}ms</span>`;
                        } else {
                            statusHtml = `<span style="color: #ef4444; font-size: 0.85em;" title="${c.error || 'æœªçŸ¥'}">âŒ å¤±è´¥</span>`;
                        }
                    } else if (c.checking) {
                        statusHtml = `<span style="color: #fbbf24; font-size: 0.85em;">â³ æ£€æµ‹ä¸­...</span>`;
                    }

                    // æ·±åº¦æ£€æµ‹ HTML
                    let visualHtml = '';
                    if (window.lastRenderShowActions) {
                        const image = c.visualImage || c.check_image;
                        const error = c.visualError || c.check_error;
                        const date = c.check_date;

                        let dateHtml = '';
                        if (date) {
                            let dateStr = date.replace(' ', 'T');
                            if (!dateStr.endsWith('Z')) dateStr += 'Z';
                            const dateObj = new Date(dateStr);
                            const now = new Date();
                            const mins = Math.floor((now - dateObj) / 60000);
                            let timeStr = mins < 60 ? `${mins}åˆ†å‰` : (mins < 1440 ? `${Math.floor(mins / 60)}æ—¶å‰` : `${Math.floor(mins / 1440)}å¤©å‰`);
                            const hhmm = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                            const isAuto = c.check_source === 'auto';
                            const autoTag = isAuto ? `<span style="background: rgba(251,191,36,0.15); color: #fbbf24; padding: 1px 4px; border-radius: 3px; font-size: 0.7em; border: 1px solid rgba(251,191,36,0.2); margin-left: 4px;">è‡ªåŠ¨</span>` : '';
                            dateHtml = `<div style="font-size: 0.75em; opacity: 0.5; margin-top: 2px;">ä¸Šæ¬¡æ£€æµ‹: ${timeStr} <small>(${hhmm})</small> ${autoTag}</div>`;
                        }

                        if (c.visualStatus === 'loading') {
                            visualHtml = `<td style="padding: 10px; font-size: 0.85em;">ğŸ”„ æ£€æµ‹ä¸­...</td>`;
                        } else if ((c.visualStatus === 'ok' || !c.visualStatus) && image) {
                            visualHtml = `<td style="padding: 10px;">
                                <img src="${image}" style="height: 40px; cursor: zoom-in;" onclick="event.stopPropagation(); showLightbox('${image}')" title="ç‚¹å‡»æ”¾å¤§">
                                ${dateHtml}
                            </td>`;
                        } else if (c.visualStatus === 'error' || error) {
                            visualHtml = `<td style="padding: 10px;">
                                <div style="color: #ef4444; font-size: 0.8em;" title="${error || 'æ£€æµ‹å¤±è´¥'}">âŒ æ— ç”»é¢</div>
                                ${dateHtml}
                            </td>`;
                        } else {
                            visualHtml = `<td style="padding: 10px; font-size: 0.8em; opacity: 0.5;">-</td>`;
                        }
                    }

                    return `
                    <tr onclick="handleCardClick(event, ${c.id})" class="${window.selectedChannelIds.has(c.id) ? 'card-selected' : ''}" style="border-bottom: 1px solid var(--glass-border); ${c.is_enabled === false ? 'opacity: 0.5; background: rgba(0,0,0,0.2);' : ''}">
                        ${window.lastRenderShowActions ? `<td style="padding: 10px;"><input type="checkbox" class="ch-checkbox" data-id="${c.id}" ${window.selectedChannelIds.has(c.id) ? 'checked' : ''} onchange="toggleChannelSelection(${c.id}, this.checked)"></td>` : ''}
                        <td id="logo_${renderOffset}_${batch.indexOf(c)}" style="padding: 10px;" data-label="Logo">${c.logo ? `<img src="${c.logo}" style="height:30px; border-radius:4px" onerror="this.style.display='none'">` : ''}</td>
                        <td style="padding: 10px;" data-label="åç§°ï¼š">${c.name}</td>
                        <td style="padding: 10px;" data-label="TVGï¼š"><span style="font-size: 0.8em; opacity: 0.6;">${c.tvg_id || '-'}</span></td>
                        ${window.currentEPGUrl ? `
                        <td id="epg_${renderOffset}_${batch.indexOf(c)}" style="padding: 10px;" data-label="èŠ‚ç›®ï¼š">
                            <span style="font-size: 0.85em; color: var(--text-loading);">â³ åŠ è½½ä¸­...</span>
                        </td>` : ''}
                        <td style="padding: 10px;" data-label="åˆ†ç»„ï¼š">${c.group || 'é»˜è®¤'}</td>
                        ${window.lastRenderShowActions ? `<td style="padding: 10px;" data-label="æ¥æºï¼š"><span style="font-size: 0.85em; opacity: 0.7;">${c.source || 'æœªçŸ¥'}</span></td>` : ''}
                        ${window.lastRenderShowActions ? `<td style="padding: 10px;" data-label="çŠ¶æ€ï¼š">${statusHtml}</td>` : ''}
                        ${visualHtml.replace('<td ', '<td data-label="ç”»é¢é¢„è§ˆï¼š" ')}
                        ${window.lastRenderShowActions ? `
                        <td style="padding: 10px;">
                            <button class="btn btn-sm" 
                                style="background: ${c.is_enabled !== false ? '#ef4444' : '#10b981'}; padding: 4px 8px; font-size: 0.8em;"
                                onclick="toggleChannel(${c.id})">
                                ${c.is_enabled !== false ? 'ç¦ç”¨' : 'å¯ç”¨'}
                            </button>
                        </td>` : ''}
                    </tr>
                `}).join('');
            }

            if (renderOffset === 0) {
                list.innerHTML = html;
            } else {
                list.insertAdjacentHTML('beforeend', html);
            }

            // æ‰¹é‡åŠ è½½ EPG (é˜²å¡æ­»)
            if (window.currentEPGUrl) {
                batch.forEach((c, idx) => {
                    const isRefresh = !!window.forceRefreshEPG || (window.refreshSelectedOnly && window.selectedChannelIds.has(c.id));
                    // ç§»åŠ¨ç«¯ä½¿ç”¨ä¸åŒçš„ cell ID å‰ç¼€
                    const cellId = isMobileCardMode ? `mobile_epg_${renderOffset}_${idx}` : `epg_${renderOffset}_${idx}`;
                    enqueueEpgLoad(window.currentEPGUrl, c.tvg_id, c.name, cellId, c.logo, c.id, isRefresh);
                });
            }

            renderOffset = end;

            // æ›´æ–°"åŠ è½½æ›´å¤š"æŒ‰é’®
            const btnContainer = document.getElementById('load_more_container');
            if (btnContainer) {
                if (renderOffset >= filteredChannels.length) {
                    btnContainer.style.display = 'none';
                } else {
                    btnContainer.style.display = 'block';
                    const btn = btnContainer.querySelector('button');
                    if (btn) btn.innerText = `æŸ¥çœ‹æ›´å¤š (å‰©ä½™ ${filteredChannels.length - renderOffset} æ¡)`;
                }
            }
        }

        // ç§»åŠ¨ç«¯å¡ç‰‡ç‚¹å‡»å¤„ç†
        function handleMobileCardClick(event, id) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ã€å¤é€‰æ¡†æˆ–å›¾ç‰‡ï¼Œåˆ™ä¸å¤„ç†
            if (event.target.closest('button') || event.target.closest('input') || event.target.closest('.mobile-channel-card__bg img')) {
                return;
            }
            const checkbox = document.querySelector(`.mobile-channel-card[data-id="${id}"] .ch-checkbox`);
            if (checkbox) {
                const newState = !checkbox.checked;
                checkbox.checked = newState;
                toggleChannelSelection(id, newState);
                updateMobileCardSelection(id, newState);
            }
        }

        // æ›´æ–°ç§»åŠ¨ç«¯å¡ç‰‡é€‰ä¸­çŠ¶æ€
        function updateMobileCardSelection(id, isSelected) {
            const card = document.querySelector(`.mobile-channel-card[data-id="${id}"]`);
            if (card) {
                if (isSelected) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            }
        }

        // EPG æ€§èƒ½ä¼˜åŒ–
        window.epgCache = new Map(); // ä¼šè¯çº§ç¼“å­˜
        const pendingEpgRequests = new Map(); // è¯·æ±‚å»é‡

        async function loadChannelEPG(epgUrl, tvgId, tvgName, cellId, currentLogo, channelId, isRefresh = false) {
            const cell = document.getElementById(cellId);
            if (!cell) return;

            try {
                // åˆå¹¶/å»é‡ Key (ç¼“å­˜ Key ä¸åº”åŒ…å« refresh çŠ¶æ€ï¼Œå¦åˆ™åˆ·æ–°åçš„ç»“æœæ— æ³•å¤ç”¨)
                const dedupeKey = `${epgUrl}_${tvgId}_${tvgName}`;

                // 1. æ£€æŸ¥ç¼“å­˜ (å¦‚æœä¸æ˜¯åˆ·æ–°è¯·æ±‚ï¼Œåˆ™å°è¯•è¯»ç¼“å­˜)
                if (!isRefresh && window.epgCache.has(dedupeKey)) {
                    applyEpgData(cell, window.epgCache.get(dedupeKey), cellId);
                    return;
                }

                // 2. æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒè¯·æ±‚åœ¨å¤„ç†
                if (pendingEpgRequests.has(dedupeKey)) {
                    const data = await pendingEpgRequests.get(dedupeKey);
                    applyEpgData(cell, data, cellId);
                    return;
                }

                // 3. å‘èµ·è¯·æ±‚
                const fetchPromise = (async () => {
                    const url = `/api/epg/current?epg_url=${encodeURIComponent(epgUrl)}&tvg_id=${encodeURIComponent(tvgId || '')}&tvg_name=${encodeURIComponent(tvgName || '')}&current_logo=${encodeURIComponent(currentLogo || '')}&refresh=${isRefresh}`;
                    const res = await fetch(url);
                    return await res.json();
                })();

                pendingEpgRequests.set(dedupeKey, fetchPromise);

                const data = await fetchPromise;
                // æˆåŠŸåæ›´æ–°ç¼“å­˜ (åˆ·æ–°è¯·æ±‚ä¹Ÿä¼šè¦†ç›–ç¼“å­˜)
                window.epgCache.set(dedupeKey, data);
                pendingEpgRequests.delete(dedupeKey);

                applyEpgData(cell, data, cellId);
            } catch (e) {
                if (cell) {
                    cell.innerText = 'åŠ è½½å¤±è´¥';
                    cell.style.color = 'var(--text-failure, #ef4444)';
                    cell.title = e.message;
                    console.error("EPG Load Error:", e);
                }
            }
        }

        function applyEpgData(cell, data, cellId) {
            cell.innerText = data.program || 'æ— èŠ‚ç›®ä¿¡æ¯';
            if (data.program && data.program !== 'No Program Info') {
                cell.style.color = 'var(--text-highlight)';
                cell.style.opacity = '1';
            } else {
                cell.style.opacity = '0.5';
            }

            // æ›´æ–°å°æ ‡é€»è¾‘
            if (data.logo) {
                const logoCellId = cellId.replace('epg_', 'logo_');
                const logoCell = document.getElementById(logoCellId);
                if (logoCell) {
                    const img = logoCell.querySelector('img');
                    if (!img || img.style.display === 'none') {
                        logoCell.innerHTML = `<img src="${data.logo}" style="height:30px; border-radius:4px">`;
                    }
                }
            }
        }

        // EPG è¯·æ±‚é˜Ÿåˆ— (é˜²å¡æ­»)
        const epgQueue = [];
        let activeEpgRequests = 0;
        const MAX_EPG_CONCURRENCY = 5; // é™ä½å¹¶å‘ï¼Œå‡å°‘æœåŠ¡ç«¯å‹åŠ›
        const EPG_REQ_TIMEOUT = 12000; // 12ç§’é™ˆæ—§è¯·æ±‚è‡ªåŠ¨ä¸¢å¼ƒ

        function enqueueEpgLoad(...args) {
            epgQueue.push({
                args: args,
                time: Date.now()
            });
            processEpgQueue();
        }

        async function processEpgQueue() {
            if (activeEpgRequests >= MAX_EPG_CONCURRENCY || epgQueue.length === 0) return;

            const item = epgQueue.shift();
            // å¦‚æœè¯·æ±‚å¤ªæ—§äº†ï¼ˆæ¯”å¦‚æ»‘åŠ¨å¾ˆå¿«äº§ç”Ÿçš„è¿‡å¾€è¯·æ±‚ï¼‰ï¼Œç›´æ¥ä¸¢å¼ƒ
            if (Date.now() - item.time > EPG_REQ_TIMEOUT) {
                processEpgQueue();
                return;
            }

            activeEpgRequests++;
            try {
                await loadChannelEPG(...item.args);
            } finally {
                activeEpgRequests--;
                setTimeout(processEpgQueue, 20); // ç¨å¾®æ‹‰å¼€ä¸€ç‚¹é—´è·
            }
        }

        async function refreshEPG() {
            if (!window.currentEPGUrl) return;

            if (window.selectedChannelIds.size === 0) {
                alert("è¯·å…ˆå‹¾é€‰éœ€è¦æ“ä½œçš„é¢‘é“ï¼");
                return;
            }

            const btn = document.getElementById('refresh_epg_btn');
            btn.innerText = 'æ­£åœ¨æ›´æ–°...';
            btn.disabled = true;

            // window.forceRefreshEPG = true; // ä¸å†å…¨éƒ¨å¼ºåˆ¶
            window.refreshSelectedOnly = true;

            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            window.refreshSelectedOnly = false;

            btn.innerText = 'ğŸ”„ åˆ·æ–°èŠ‚ç›®è¡¨';
            btn.disabled = false;
        }

        async function checkPageConnectivity() {
            // ç¡®å®šæ£€æµ‹ç›®æ ‡
            let targetChannels = [];
            if (window.selectedChannelIds.size > 0) {
                targetChannels = filteredChannels.filter(c => window.selectedChannelIds.has(c.id));
            } else {
                alert("è¯·å…ˆå‹¾é€‰éœ€è¦æ“ä½œçš„é¢‘é“ï¼");
                return;
            }

            if (targetChannels.length === 0) return;

            const confirmMsg = `å³å°†æ£€æµ‹é€‰ä¸­çš„ ${targetChannels.length} ä¸ªé¢‘é“çš„è¿é€šæ€§ (è€—æ—¶è¾ƒé•¿)ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ`;
            if (targetChannels.length > 500 && !confirm(confirmMsg)) return;

            // æ ‡è®°æ£€æµ‹ä¸­
            targetChannels.forEach(c => c.checking = true);

            // ç«‹å³æ¸²æŸ“åŠ è½½åŠ¨ç”»
            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            // åˆ†æ‰¹å¤„ç† (æ¯æ‰¹ 50)
            const chunkSize = 50;
            for (let i = 0; i < targetChannels.length; i += chunkSize) {
                const chunk = targetChannels.slice(i, i + chunkSize);
                // å‘é€å¸¦ ID çš„åˆ—è¡¨
                const items = chunk.map(c => ({ id: c.id, url: c.url }));

                try {
                    const res = await fetch('/check-connectivity', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ items: items })
                    });
                    const results = await res.json();

                    results.forEach(r => {
                        // ç®€å•é€šè¿‡ URL åŒ¹é…
                        chunk.filter(c => c.url === r.url).forEach(c => {
                            c.checking = false;
                            c.status = r.status;
                            c.latency = r.latency;
                            c.error = r.error;
                        });
                    });

                } catch (err) {
                    console.error("Check failed for batch", err);
                    chunk.forEach(c => { c.checking = false; c.error = "Check Failed"; });
                }

                renderOffset = 0;
                renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);
            }
        }

        async function checkVisualConnectivity() {
            const btn = document.getElementById('check_visual_btn');

            // å¦‚æœæ­£åœ¨æ£€æŸ¥ï¼Œè®¾ç½®æ ‡å¿—ä¸º false ä»¥å–æ¶ˆ
            if (window.isVisualChecking) {
                window.isVisualChecking = false;
                btn.innerText = "â³ æ­£åœ¨å–æ¶ˆ...";
                btn.disabled = true;
                return;
            }

            if (filteredChannels.length === 0) return;

            // 1. æŸ¥æ‰¾å“ªäº›æ˜¯è¿˜æ²¡æ£€æµ‹è¿‡çš„
            const freshThreshold = 30 * 60 * 1000;
            const now = new Date();

            // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­é¢‘é“æ˜¯å¦å·²ç»æœ‰äº†â€œæ–°é²œâ€çš„æ£€æµ‹ç»“æœ
            const isFreshlyFinished = (c) => {
                if (c.visualStatus) return true; // æœ¬è½®æ£€æµ‹è¿‡çš„
                if (!c.check_date) return false; // æ ¹æœ¬æ²¡æ£€æµ‹è¿‡

                try {
                    // å…¼å®¹å„ç§æ—¥æœŸæ ¼å¼ï¼Œç¡®ä¿è§£ææ­£ç¡®
                    const dateStr = c.check_date.endsWith('Z') ? c.check_date : c.check_date.includes('+') ? c.check_date : c.check_date + 'Z';
                    const dateObj = new Date(dateStr);
                    return (now - dateObj) < freshThreshold;
                } catch (e) {
                    return false;
                }
            };

            const pendingChannels = filteredChannels.filter(c => !isFreshlyFinished(c));
            const completedCount = filteredChannels.length - pendingChannels.length;

            let targets = filteredChannels;
            if (completedCount > 0 && pendingChannels.length > 0) {
                // å¦‚æœæœ‰æ–°é²œç»“æœï¼Œæç¤ºæ˜¯å¦è·³è¿‡
                if (confirm(`å½“å‰åˆ—è¡¨å…± ${filteredChannels.length} ä¸ªé¢‘é“ï¼š\n- 30åˆ†é’Ÿå†…å·²æœ‰ç»“æœ: ${completedCount} ä¸ª\n- å¾…æ£€æµ‹/ä¸Šæ¬¡å¤±è´¥: ${pendingChannels.length} ä¸ª\n\næ˜¯å¦ä»…æ£€æµ‹â€œå¾…æ£€æµ‹/ä¸Šæ¬¡å¤±è´¥â€çš„é¢‘é“ï¼Ÿ\n(ç¡®å®šï¼šæ–­ç‚¹ç»­ä¼ ï¼› å–æ¶ˆï¼šå…¨éƒ¨é‡æ–°æ£€æµ‹)`)) {
                    targets = pendingChannels;
                }
            } else if (pendingChannels.length === 0 && filteredChannels.length > 0) {
                // æ‰€æœ‰éƒ½æ²¡å˜åŠ¨ï¼Œæç¤ºå…¨éƒ¨é‡æµ‹
                if (!confirm(`æ‰€æœ‰ ${filteredChannels.length} ä¸ªé¢‘é“åœ¨ 30 åˆ†é’Ÿå†…éƒ½å·²æ£€æµ‹è¿‡ï¼Œæ˜¯å¦è¦å…¨éƒ¨é‡æ–°æ£€æµ‹ï¼Ÿ`)) {
                    return;
                }
            }

            const count = targets.length;
            const confirmMsg = `å³å°†å¯¹ ${count} ä¸ªé¢‘é“è¿›è¡Œæ·±åº¦æ£€æµ‹ï¼ˆæˆªå›¾ï¼‰ã€‚\nè¿™å°†ä¼šéå¸¸è€—æ—¶ï¼ˆæ¯ä¸ªé¢‘é“çº¦ 3-5 ç§’ï¼‰ã€‚\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`;
            if (count > 20 && !confirm(confirmMsg)) return;

            window.isVisualChecking = true;
            btn.disabled = false;
            btn.innerText = "ğŸ›‘ å–æ¶ˆæ£€æµ‹";
            const originalBg = btn.style.background;
            btn.style.background = "var(--danger)";

            const autoDisable = document.getElementById('auto_disable_check').checked;

            // åˆå§‹æ ‡è®°ä¸º loading (ä»…é’ˆå¯¹æœ¬æ¬¡è¦æ£€æµ‹çš„ç›®æ ‡)
            targets.forEach(c => c.visualStatus = 'loading');
            renderOffset = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            // åˆ†æ‰¹å¤„ç† (æ·±åº¦æ£€æµ‹è¦æ…¢ç‚¹)
            const chunkSize = 5;
            let finishedInThisSession = 0;

            for (let i = 0; i < targets.length; i += chunkSize) {
                if (!window.isVisualChecking) break;

                const chunk = targets.slice(i, i + chunkSize);
                const items = chunk.map(c => ({ id: c.id, url: c.url }));

                // æ›´æ–°æŒ‰é’®è¿›åº¦
                btn.innerText = `ğŸ›‘ å–æ¶ˆ (${finishedInThisSession}/${count})`;

                try {
                    const res = await fetch('/check-stream-visual', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ items: items, auto_disable: autoDisable })
                    });
                    const results = await res.json();

                    results.forEach(r => {
                        const match = chunk.find(c => c.id === r.id);
                        if (match) {
                            finishedInThisSession++;
                            if (r.status) {
                                match.visualStatus = 'ok';
                                match.visualImage = r.image;
                                match.check_status = true;
                                match.check_image = r.image;
                                match.check_date = new Date().toISOString();
                            } else {
                                match.visualStatus = 'error';
                                match.visualError = r.error || 'æ£€æµ‹å¤±è´¥';
                                match.check_status = false;
                                match.check_image = null;

                                if (r.auto_disabled) {
                                    match.is_enabled = false;
                                }
                            }
                        }
                    });
                } catch (err) {
                    chunk.forEach(c => {
                        c.visualStatus = 'error';
                        c.visualError = "ç½‘ç»œé”™è¯¯";
                        c.check_status = false;
                        c.check_image = null;
                        finishedInThisSession++;
                    });
                }

                renderOffset = 0;
                renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);
            }

            // æ”¶å°¾
            const wasCancelled = !window.isVisualChecking;
            window.isVisualChecking = false;
            btn.disabled = false;
            btn.innerText = "ğŸ“º æ·±åº¦æ£€æµ‹";
            btn.style.background = originalBg;

            // å¦‚æœæ˜¯ä¸­é€”å–æ¶ˆçš„ï¼ŒæŠŠè¿˜æ²¡è½®åˆ°çš„ loading çŠ¶æ€æ¸…æ‰ï¼Œä¿ç•™å·²å®Œæˆçš„
            targets.forEach(c => {
                if (c.visualStatus === 'loading') {
                    c.visualStatus = null;
                }
            });

            renderOffset = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            if (!wasCancelled) {
                showToast(`æ·±åº¦æ£€æµ‹åœ†æ»¡å®Œæˆï¼å…±å¤„ç† ${finishedInThisSession} ä¸ªé¢‘é“ã€‚`, 'success');
            } else {
                showToast(`æ£€æµ‹å·²æå‰ä¸­æ–­ï¼Œå·²ä¿å­˜ ${finishedInThisSession} ä¸ªç»“æœã€‚`, 'warning');
            }
        }

        async function toggleChannel(id) {
            try {
                const res = await fetch(`/channels/${id}/toggle`, { method: 'POST' });
                if (!res.ok) throw new Error("æ“ä½œå¤±è´¥");
                const updated = await res.json();

                // æ›´æ–°æœ¬åœ°æ•°æ®
                const item = currentChannels.find(c => c.id === id);
                if (item) {
                    item.is_enabled = updated.is_enabled;
                    // å±€éƒ¨æ›´æ–° UIï¼šä¸å†é‡ç½®åç§»å’Œæ»šåŠ¨æ¡ï¼Œä»…æ›´æ–°ç‰¹å®šè¡Œ
                    const toggleBtns = document.querySelectorAll(`button[onclick*="toggleChannel(${id})"]`);
                    toggleBtns.forEach(btn => {
                        const enable = updated.is_enabled !== false;
                        btn.innerText = enable ? 'ç¦ç”¨' : 'å¯ç”¨';
                        btn.style.background = enable ? '#ef4444' : '#10b981';
                        // æ›´æ–°è¡Œæ ·å¼
                        const tr = btn.closest('tr');
                        if (tr) {
                            tr.style.opacity = enable ? '1' : '0.5';
                            tr.style.background = enable ? 'transparent' : 'rgba(0,0,0,0.2)';
                        }
                    });
                    updatePreviewStats();
                }
            } catch (err) {
                alert("æ“ä½œå¤±è´¥: " + err.message);
            }
        }

        async function fetchSubs() {
            const res = await fetch('/subscriptions/');
            const data = await res.json();

            // æ¸²æŸ“è®¢é˜…ç®¡ç†åˆ—è¡¨
            const list = document.getElementById('sub_list');
            list.innerHTML = data.map(s => {
                const statusColor = s.last_update_status && (s.last_update_status.includes('å¤±è´¥') || s.last_update_status.includes('Error')) ? '#ef4444' : '#10b981';
                const opacity = s.is_enabled ? '1' : '0.5';
                const toggleText = s.is_enabled ? 'ç¦ç”¨' : 'å¯ç”¨';
                const toggleColor = s.is_enabled ? '#f59e0b' : '#10b981';

                return `
                <div id="sub_item_${s.id}" class="sub-item" style="margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--glass-border); padding-bottom: 8px; opacity: ${opacity};">
                    <div style="cursor: pointer; flex-grow: 1;" onclick="viewChannels(${s.id}, '${(s.name || s.url).replace(/'/g, "\\'")}', '${s.epg_url || ''}')">
                        <strong style="color: ${s.name ? 'inherit' : '#94a3b8'};">${s.name || 'æœªå‘½åè®¢é˜… (' + s.url.substring(0, 20) + '...)'}</strong>
                        ${!s.is_enabled ? '<span style="background: #64748b; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; margin-left: 8px;">å·²ç¦ç”¨</span>' : ''}
                        ${s.epg_url ? '<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; margin-left: 8px;">EPG</span>' : ''}
                        <br>
                        <small style="opacity: 0.6;">${s.url.substring(0, 50)}...</small>
                        <div style="font-size: 0.8em; margin-top: 4px; opacity: 0.8;">
                            ğŸ“… ${formatDate(s.last_updated)} 
                            <span style="color: ${statusColor}; margin-left: 8px;">
                                ${s.last_update_status || 'ç­‰å¾…æ›´æ–°'}
                            </span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-sm" style="background: ${toggleColor};" onclick="toggleSubActive(${s.id}, ${s.is_enabled})">${toggleText}</button>
                        <button class="btn btn-sm" style="background: var(--primary);" onclick="prepareEditSub(${s.id}, '${(s.name || "").replace(/'/g, "\\'")}', '${s.url}', '${s.user_agent}', ${s.auto_update_minutes || 0}, ${s.is_enabled})">ä¿®æ”¹</button>
                        <button class="btn btn-sm" style="background: #10b981;" onclick="refreshSub(${s.id})">åˆ·æ–°</button>
                        <button class="btn btn-sm" style="background: #3b82f6;" onclick="viewChannels(${s.id}, '${(s.name || s.url).replace(/'/g, "\\'")}', '${s.epg_url || ''}')">æŸ¥çœ‹</button>
                        <button class="btn btn-sm" style="background: #ef4444;" onclick="deleteSub(${s.id})">åˆ é™¤</button>
                    </div>
                </div>
            `}).join('') || 'æš‚æ— è®¢é˜…';

            // èšåˆé¡µé¢çš„è®¢é˜…é€‰æ‹© (ä»…æ˜¾ç¤ºå¯ç”¨çš„)
            const selector = document.getElementById('sub_selector');
            selector.innerHTML = data.filter(s => s.is_enabled).map(s => `
                <label class="sub-checkbox-item">
                    <input type="checkbox" name="selected_subs" value="${s.id}" onchange="debounceUpdatePreview()">
                    <span>${s.name || s.url}</span>
                </label>
            `).join('') || (data.length > 0 ? 'æ‰€æœ‰è®¢é˜…å‡å·²ç¦ç”¨' : 'è¯·å…ˆæ·»åŠ è®¢é˜…æº');
        }

        window._subLastScrollY = 0;
        function prepareEditSub(id, name, url, ua, autoMinutes, isEnabled) {
            window._subLastScrollY = window.scrollY; // è®°å½•ä½ç½®
            document.getElementById('sub_form_container').scrollIntoView({ behavior: 'smooth' });

            document.getElementById('edit_sub_id').value = id;
            document.getElementById('sub_is_enabled').value = isEnabled === undefined ? true : isEnabled;
            document.getElementById('sub_name').value = name;
            document.getElementById('sub_url').value = url;
            document.getElementById('sub_ua').value = ua;
            // è®¾ç½®è‡ªåŠ¨æ›´æ–°é¡¹
            document.getElementById('sub_auto_update').value = autoMinutes || 0;

            // è‡ªåŠ¨åˆ‡é¡µç­¾
            if (url.endsWith('.git') || url.includes('.git/') || (url.includes('github.com') && !url.includes('/raw/'))) {
                switchSubTab('git');
            } else {
                switchSubTab('normal');
            }

            document.getElementById('sub_form_title').innerText = 'ğŸ“ ä¿®æ”¹è®¢é˜…æº';
            document.getElementById('sub_btn').innerText = 'ä¿å­˜ä¿®æ”¹';
            document.getElementById('sub_cancel_btn').style.display = 'block';
            document.getElementById('sub_form_container').classList.add('edit-mode');

            // çªå‡ºæ˜¾ç¤º
            document.querySelectorAll('.sub-item').forEach(el => el.style.opacity = '0.4');
            document.getElementById(`sub_item_${id}`).style.opacity = '1';
        }

        function cancelEditSub() {
            if (window._subLastScrollY !== undefined) {
                window.scrollTo({ top: window._subLastScrollY, behavior: 'smooth' });
            }
            document.getElementById('edit_sub_id').value = '';
            document.getElementById('sub_name').value = '';
            document.getElementById('sub_url').value = '';
            document.getElementById('sub_ua').value = '';
            document.getElementById('sub_auto_update').value = '0';

            switchSubTab('normal');

            document.getElementById('sub_form_title').innerText = 'â• æ·»åŠ è®¢é˜…æº';
            document.getElementById('sub_btn').innerText = 'æ·»åŠ è®¢é˜…';
            document.getElementById('sub_cancel_btn').style.display = 'none';
            document.getElementById('sub_form_container').classList.remove('edit-mode');
            document.querySelectorAll('.sub-item').forEach(el => el.style.opacity = '1');
        }

        // å…³é”®å­—æ ‡ç­¾é€»è¾‘
        // é¢„æœŸæ ¼å¼: { value: 'k', group: 'g' }
        let keywords = [];

        document.getElementById('tag_input').addEventListener('keydown', handleTagInput);

        function handleTagInput(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const input = document.getElementById('tag_input');
                const val = input.value.trim();

                if (val) {
                    // å»é‡
                    const exists = keywords.some(k => k.value === val);
                    if (!exists) {
                        keywords.push({ value: val, group: '' });

                        // è‡ªåŠ¨åˆ‡åˆ°æ–°æ ‡ç­¾
                        activeKeyword = val;

                        // æ¸…ç©ºè¾“å…¥
                        input.value = '';
                        renderTags();

                        // é˜²æŠ–é¢„è§ˆ
                        clearTimeout(window.previewDebounceTimer);
                        window.previewDebounceTimer = setTimeout(updateRealtimePreview, 300);
                    } else {
                        // é‡å¤çš„è¯æ¸…ç©ºè¾“å…¥æ¡†
                        input.value = '';
                    }
                }
            }
        }

        // é¢„è§ˆå…¨å±€çŠ¶æ€
        let lastPreviewData = {};
        let activeKeyword = null; // å­˜çš„æ˜¯å­—ç¬¦ä¸²

        function renderTags() {
            const container = document.getElementById('tag_container');
            const input = document.getElementById('tag_input');

            // åˆ æ‰æ—§æ ‡ç­¾
            container.querySelectorAll('.tag').forEach(el => el.remove());

            // æ„å»º HTML
            const tagsHtml = keywords.map(k => {
                const isActive = k.value === activeKeyword ? 'active-tag' : '';
                const display = k.group ? `${k.value} <span style="opacity:0.6; font-size:0.9em">â†’ ${k.group}</span>` : k.value;
                return `
                    <span class="tag ${isActive}" onclick="selectKeyword('${k.value.replace(/'/g, "\\'")}')">
                        ${display}
                        <span class="tag-remove" onclick="event.stopPropagation(); removeTag('${k.value.replace(/'/g, "\\'")}')">&times;</span>
                    </span>
                `;
            }).join('');

            // è¿˜åŸ HTML
            container.innerHTML = tagsHtml + `
                <div style="display: flex; flex-grow: 1; align-items: center; gap: 5px;">
                    <input type="text" id="tag_input" placeholder="å…³é”®å­—" value="${input.value}"
                        style="background: transparent; border: none; outline: none; flex-grow: 2; padding: 0;">
                </div>
            `;

            // é‡æ–°ç»‘äº‹ä»¶
            document.getElementById('tag_input').addEventListener('keydown', handleTagInput);
            document.getElementById('tag_input').focus();
        }

        function removeTag(val) {
            keywords = keywords.filter(k => k.value !== val);
            if (activeKeyword === val) {
                activeKeyword = keywords.length > 0 ? keywords[keywords.length - 1].value : null;
            }
            renderTags();
            // é˜²æŠ–
            clearTimeout(window.previewDebounceTimer);
            window.previewDebounceTimer = setTimeout(updateRealtimePreview, 300);
        }

        function selectKeyword(k) {
            activeKeyword = k;
            renderTags();
            renderSelectedPreview();
        }

        function updateKeywordGroup(val, newGroup) {
            const kObj = keywords.find(k => k.value === val);
            if (kObj) {
                kObj.group = newGroup.trim();
                renderTags(); // æ›´æ–°æ˜¾ç¤º
                // æ›´æ–°é¢„è§ˆæ ‡é¢˜

                // è§¦å‘é¢„è§ˆæ›´æ–°
                clearTimeout(window.previewDebounceTimer);
                window.previewDebounceTimer = setTimeout(updateRealtimePreview, 500);
            }
        }

        function renderSelectedPreview() {
            const previewWin = document.getElementById('preview_window');

            if (!activeKeyword || !lastPreviewData) {
                if (keywords.length === 0 && lastPreviewData && lastPreviewData["All"]) {
                    // æš‚ä¸”éšè—
                    previewWin.style.display = 'none';
                    return;
                }
                previewWin.style.display = 'none';
                return;
            }

            const kObj = keywords.find(k => k.value === activeKeyword);
            if (!kObj) {
                previewWin.style.display = 'none';
                return;
            }

            // æ‰¾æ•°æ®
            const displayKey = kObj.group ? `${kObj.value} â†’ ${kObj.group}` : kObj.value;

            // æ²¡é¢‘é“ä¹Ÿç»™å®ƒç”»ä¸ªå¤´
            renderPreviewGroup(kObj, lastPreviewData[displayKey] || []);
        }

        function renderPreviewGroup(kObj, channels) {
            const previewWin = document.getElementById('preview_window');
            if (!kObj) return;

            const key = kObj.value;
            const groupVal = kObj.group || '';

            const channelsHtml = (channels && channels.length > 0) ? channels.map(c => `
                    <div class="preview-item">
                        ${c.logo ? `<img src="${c.logo}" onerror="this.style.display='none'">` : '<div style="width:20px"></div>'}
                        <div style="flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            <strong>${c.name}</strong><br>
                            <small style="opacity: 0.8; font-size: 0.85em; color: #a5b4fc;">æ¥æº: ${c.source}</small>
                        </div>
                        <small style="opacity: 0.4; margin-left: 5px;">${c.group || 'é»˜è®¤'}</small>
                    </div>
                `).join('') : '<div style="opacity: 0.5; padding: 10px;">è¯¥æ ‡ç­¾ä¸‹æ²¡æœ‰åŒ¹é…çš„é¢‘é“</div>';

            const html = `
                <div id="preview-group-${key}" style="margin-top: 5px; border-left: 3px solid var(--primary); padding-left: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.03); display: flex; align-items: center; justify-content: space-between; padding-right: 10px;">
                    <div>
                        <small style="color: var(--primary); font-weight: bold; text-transform: uppercase;">${key}</small>
                        <span style="font-size: 0.8em; opacity: 0.5; margin-left: 5px;">åŒ¹é…: ${channels ? channels.length : 0}</span>
                    </div>
                    <input type="text" placeholder="è®¾ç½®åˆ†ç»„" value="${groupVal}" 
                        onchange="updateKeywordGroup('${key.replace(/'/g, "\\'")}', this.value)"
                        style="background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: 4px; padding: 2px 8px; width: 120px; font-size: 0.85em; color: #fff;">
                </div>
                ${channelsHtml}
            `;

            previewWin.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 5px;">
                    <span style="opacity: 0.7; font-size: 0.8em;">åŒ¹é…ä¸åˆ†ç»„è®¾ç½®:</span>
                    <span onclick="document.getElementById('preview_window').style.display='none'" 
                          style="cursor:pointer; font-size: 1.2em; line-height: 0.5; opacity: 0.8;">&times;</span>
                </div>
                ${html}`;
            previewWin.style.display = 'block';
        }

        // å¼¹çª—ç³»ç»Ÿ
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            let icon = 'â„¹ï¸';
            if (type === 'success') icon = 'âœ…';
            if (type === 'error') icon = 'âŒ';

            toast.innerHTML = `<span style="margin-right:8px">${icon}</span> ${message}`;

            container.appendChild(toast);

            // è‡ªåŠ¨ç§»é™¤
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s forwards';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // å…¼å®¹æ—§ç‰ˆæˆ–ç®€å†™æç¤º
        function showStatus(msg) {
            showToast(msg, 'info');
        }

        // --- ç»“æŸ ---

        async function updateRealtimePreview() {
            const previewWin = document.getElementById('preview_window');
            const selectedSubs = Array.from(document.querySelectorAll('input[name="selected_subs"]:checked')).map(cb => parseInt(cb.value));

            if (selectedSubs.length === 0 && keywords.length === 0) {
                previewWin.style.display = 'none';
                return;
            }

            const data = {
                subscription_ids: selectedSubs,
                keywords: keywords,
                filter_regex: document.getElementById('out_regex').value || ".*"
            };

            try {
                const res = await fetch('/outputs/preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const groupedResults = await res.json();
                lastPreviewData = groupedResults;

                if (keywords.length > 0) {
                    // æ ¡éªŒå½“å‰æ ‡ç­¾æ˜¯å¦è¿˜æœ‰æ•ˆ
                    if (!activeKeyword || !keywords.some(k => k.value === activeKeyword)) {
                        activeKeyword = keywords[keywords.length - 1].value;
                    }
                } else {
                    activeKeyword = null;
                }

                renderTags();
                renderSelectedPreview();

            } catch (err) {
                console.error('é¢„è§ˆåŠ è½½å¤±è´¥:', err);
                previewWin.style.display = 'none';
            }
        }


        function closePreview() {
            const modal = document.getElementById('channel_modal');
            modal.style.setProperty('display', 'none', 'important');
            document.body.style.overflow = '';
        }

        function handleModalScroll(el) {
            const btt = document.getElementById('back-to-top');
            if (el.scrollTop > 600) {
                btt.style.display = 'flex';
            } else {
                btt.style.display = 'none';
            }
        }

        function scrollToTop() {
            document.getElementById('channel_list_container').scrollTo({ top: 0, behavior: 'smooth' });
        }

        async function deleteSub(id) {
            console.log('å°è¯•åˆ é™¤è®¢é˜…:', id);
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè®¢é˜…å—ï¼Ÿ')) return;
            // äºŒæ¬¡ç¡®è®¤
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šåˆ é™¤è®¢é˜…å°†ç§»é™¤ç›¸å…³æ•°æ®ï¼Œç¡®å®šå—ï¼Ÿ')) return;

            try {
                const res = await fetch(`/subscriptions/${id}`, { method: 'DELETE' });
                if (res.ok) {
                    showToast('è®¢é˜…åˆ é™¤æˆåŠŸ', 'success');
                    fetchSubs();
                } else {
                    const error = await res.text();
                    console.error('åˆ é™¤å¤±è´¥:', error);
                    alert('åˆ é™¤å¤±è´¥: ' + error);
                }
            } catch (err) {
                console.error('åˆ é™¤è¿‡ç¨‹ä¸­ç½‘ç»œé”™è¯¯:', err);
                alert('ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•è¿æ¥æœåŠ¡å™¨');
            }
        }

        function toggleAllSubs(mode) {
            const checkboxes = document.querySelectorAll('input[name="selected_subs"]');
            checkboxes.forEach(cb => {
                if (mode === 1) cb.checked = true;
                else cb.checked = !cb.checked;
            });
            debounceUpdatePreview();
        }

        async function addSubscription() {
            const editId = document.getElementById('edit_sub_id').value;
            const nameInput = document.getElementById('sub_name').value.trim();
            const urlInput = document.getElementById('sub_url').value;
            const uaInput = document.getElementById('sub_ua').value;
            const autoMinutes = parseInt(document.getElementById('sub_auto_update').value);


            const urls = urlInput.split(/[\n,]+/).map(u => u.trim()).filter(u => u);

            if (urls.length === 0) {
                alert("è¯·è¾“å…¥è‡³å°‘ä¸€ä¸ªè®¢é˜…åœ°å€");
                return;
            }

            if (editId) {
                // ä¿®æ”¹æ¨¡å¼ï¼šä»…å…è®¸ä¿®æ”¹å•ä¸ª URLï¼ˆæ‰¹é‡ä¿®æ”¹å¾ˆå¤æ‚ï¼‰
                if (urls.length > 1) {
                    showToast("ä¿®æ”¹æ¨¡å¼ä¸‹ä¸æ”¯æŒæ‰¹é‡è¾“å…¥ï¼Œè¯·åªä¿ç•™ä¸€ä¸ª URL", "error");
                    return;
                }
                await submitSingleSub(editId, nameInput, urls[0], uaInput, autoMinutes, 'PUT');
            } else {
                // æ·»åŠ æ¨¡å¼ï¼šæ”¯æŒæ‰¹é‡
                showStatus(`å‡†å¤‡æ·»åŠ  ${urls.length} ä¸ªè®¢é˜…...`);
                let successCount = 0;

                for (let i = 0; i < urls.length; i++) {
                    const u = urls[i];
                    // åç§°ç”Ÿæˆè§„åˆ™: "åç§°", "åç§°_2", "åç§°_3"...
                    let name = nameInput;
                    if (urls.length > 1 && nameInput) {
                        name = (i === 0) ? nameInput : `${nameInput}_${i + 1}`;
                    }

                    const ok = await submitSingleSub(null, name, u, uaInput, autoMinutes, 'POST');
                    if (ok) successCount++;
                }

                if (successCount > 0) {
                    showStatus(`æˆåŠŸæ·»åŠ  ${successCount} / ${urls.length} ä¸ªè®¢é˜…`);
                    fetchSubs();
                    cancelEditSub();
                }
            }
        }

        async function submitSingleSub(id, name, url, ua, autoMinutes, method) {
            const sub = {
                name: name,
                url: url,
                user_agent: ua,
                headers: "{}",
                auto_update_minutes: autoMinutes,
                is_enabled: document.getElementById('sub_is_enabled').value === 'false' ? false : true
            };

            const apiUrl = id ? `/subscriptions/${id}` : '/subscriptions/';

            try {
                const res = await fetch(apiUrl, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sub)
                });

                if (res.ok) {
                    if (method === 'PUT') {
                        showToast('ä¿®æ”¹æˆåŠŸ', 'success');
                        fetchSubs();
                        cancelEditSub();
                    }
                    return true;
                } else {
                    const error = await res.json();
                    const msg = error.detail || 'æœªçŸ¥é”™è¯¯';
                    console.error(`ä¿å­˜ ${url} å¤±è´¥:`, msg);
                    if (method === 'PUT') showToast('ä¿å­˜å¤±è´¥: ' + msg, 'error');
                    return false;
                }
            } catch (err) {
                console.error(`${url} çš„ç½‘ç»œé”™è¯¯:`, err);
                if (method === 'PUT') showToast('ç½‘ç»œè¿æ¥å¤±è´¥', 'error');
                return false;
            }
        }

        async function toggleSubActive(id, currentStatus) {
            // è·å–å½“å‰è®¢é˜…æ•°æ®
            const res = await fetch('/subscriptions/');
            const subs = await res.json();
            const sub = subs.find(s => s.id === id);
            if (!sub) return;

            sub.is_enabled = !currentStatus;

            const putRes = await fetch(`/subscriptions/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(sub)
            });

            if (putRes.ok) {
                showStatus(sub.is_enabled ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨');
                fetchSubs();
            }
        }

        async function refreshSub(id) {
            showToast('æ­£åœ¨æŠ“å–ä¸­...', 'info');
            const res = await fetch(`/subscriptions/${id}/refresh`, { method: 'POST' });
            if (res.ok) {
                const data = await res.json();
                showToast(`åˆ·æ–°æˆåŠŸ: ${data.message}`, 'success');
                fetchSubs();
            } else {
                showToast('åˆ·æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥ URL æˆ–ç½‘ç»œ', 'error');
            }
        }

        async function deleteOutput(id) {
            console.log('è§¦å‘åˆ é™¤èšåˆ:', id);
            if (!confirm('ç¡®å®šåˆ é™¤æ­¤èšåˆåˆ—è¡¨å—ï¼Ÿ')) return;
            // äºŒæ¬¡ç¡®è®¤
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œç¡®å®šè¦åˆ é™¤å—ï¼Ÿ')) return;

            try {
                const res = await fetch(`/outputs/${id}`, { method: 'DELETE' });
                if (res.ok) {
                    fetchOutputs();
                } else {
                    alert('åˆ é™¤å¤±è´¥');
                }
            } catch (err) {
                alert('æ“ä½œå¤±è´¥: ' + err.message);
            }
        }
        // æŒ‚åˆ° window é˜²æ­¢ä½œç”¨åŸŸå‡ºé—®é¢˜
        window.deleteOutput = deleteOutput;

        let allOutputs = [];

        window._outLastScrollY = 0;
        function prepareEditOutput(id) {
            window._outLastScrollY = window.scrollY; // è®°å½•ä½ç½®
            document.getElementById('outputs').scrollIntoView({ behavior: 'smooth' });

            const out = allOutputs.find(o => o.id === id);
            if (!out) return;

            document.getElementById('edit_output_id').value = out.id;
            document.getElementById('out_name').value = out.name;
            document.getElementById('out_slug').value = out.slug;
            document.getElementById('out_regex').value = out.filter_regex;
            document.getElementById('out_epg').value = out.epg_url || '';
            document.getElementById('out_include_suffix').checked = out.include_source_suffix !== false;
            document.getElementById('out_is_enabled').checked = out.is_enabled !== false;
            document.getElementById('out_auto_update').value = out.auto_update_minutes || 0;
            document.getElementById('out_auto_visual').checked = out.auto_visual_check || false;

            // è¿˜åŸå…³é”®å­—
            keywords = [];
            let parsedKeys = [];
            try {
                parsedKeys = JSON.parse(out.keywords || "[]");
            } catch (e) { parsedKeys = []; }

            parsedKeys.forEach(k => {
                if (typeof k === 'string') {
                    keywords.push({ value: k, group: '' });
                } else if (typeof k === 'object') {
                    keywords.push(k);
                }
            });

            renderTags();
            activeKeyword = null; // ä¿®æ”¹æ—¶ä¸è‡ªåŠ¨é€‰ä¸­æ ‡ç­¾

            // è¿˜åŸé€‰ä¸­çš„è®¢é˜…
            const subIds = JSON.parse(out.subscription_ids || "[]");
            document.querySelectorAll('input[name="selected_subs"]').forEach(cb => {
                cb.checked = subIds.includes(parseInt(cb.value));
            });

            // æ¢ UI
            document.getElementById('out_btn').innerText = 'ä¿å­˜ä¿®æ”¹';
            document.getElementById('out_cancel_btn').style.display = 'block';
            document.getElementById('out_name').focus();
        }

        function cancelEditOutput() {
            if (window._outLastScrollY !== undefined) {
                window.scrollTo({ top: window._outLastScrollY, behavior: 'smooth' });
            }
            document.getElementById('edit_output_id').value = '';
            document.getElementById('out_name').value = '';
            document.getElementById('out_slug').value = '';
            document.getElementById('out_regex').value = '.*';
            document.getElementById('out_epg').value = '';
            document.getElementById('out_include_suffix').checked = true;
            document.getElementById('out_is_enabled').checked = true; // é»˜è®¤å¯ç”¨
            document.getElementById('out_auto_update').value = 0; // é»˜è®¤ä¸è‡ªåŠ¨æ›´æ–°
            document.getElementById('out_auto_visual').checked = false;

            keywords = [];
            renderTags();
            activeKeyword = null;

            document.querySelectorAll('input[name="selected_subs"]').forEach(cb => cb.checked = false);

            document.getElementById('out_btn').innerText = 'ç”Ÿæˆä¸“å± M3U èšåˆ URL';
            document.getElementById('out_cancel_btn').style.display = 'none';
            document.getElementById('preview_window').style.display = 'none';
        }

        async function saveOutput() {
            const id = document.getElementById('edit_output_id').value;
            const name = document.getElementById('out_name').value;
            const slug = document.getElementById('out_slug').value;

            // é€‰ä¸­çš„è®¢é˜…
            const selectedSubs = Array.from(document.querySelectorAll('input[name="selected_subs"]:checked'))
                .map(cb => parseInt(cb.value));

            if (!name || !slug) {
                alert('è¯·å¡«å†™åç§°å’Œåç¼€');
                return;
            }

            const out = {
                name: name,
                slug: slug,
                filter_regex: document.getElementById('out_regex').value,
                keywords: JSON.stringify(keywords), // Assuming 'keywords' is the global variable for tags
                subscription_ids: JSON.stringify(selectedSubs),
                epg_url: document.getElementById('out_epg').value,
                include_source_suffix: document.getElementById('out_include_suffix').checked,
                is_enabled: document.getElementById('out_is_enabled').checked,
                auto_update_minutes: parseInt(document.getElementById('out_auto_update').value),
                auto_visual_check: document.getElementById('out_auto_visual').checked
            };

            const method = id ? 'PUT' : 'POST';
            const url = id ? `/outputs/${id}` : '/outputs/';

            const res = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(out)
            });

            if (res.ok) {
                showToast(id ? 'ä¿®æ”¹æˆåŠŸ' : 'åˆ—è¡¨ç”ŸæˆæˆåŠŸï¼', 'success');
                fetchOutputs();
                cancelEditOutput();
            } else {
                const err = await res.json();
                showToast('ä¿å­˜å¤±è´¥: ' + (err.detail || 'å¯èƒ½æ˜¯åç¼€å·²å­˜åœ¨'), 'error');
            }
        }

        async function refreshOutput(id) {
            showToast('æ­£åœ¨åˆ·æ–°èšåˆå…³è”çš„æ‰€æœ‰è®¢é˜…...', 'info');
            try {
                const res = await fetch(`/outputs/${id}/refresh`, { method: 'POST' });
                if (res.ok) {
                    const data = await res.json();
                    showToast('åŸºç¡€åŒæ­¥å·²å®Œæˆ', 'success');
                    fetchOutputs();
                    fetchSubs();

                    if (data.trigger_visual) {
                        showToast('å·²è¿›å…¥åå°æ·±åº¦æ£€æµ‹é˜Ÿåˆ—ï¼Œè¯·ç¨å€™...', 'info');
                        // å¯åŠ¨ä¸€ä¸ªå°å‹è½®è¯¢ï¼Œæ¯ 3 ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œæœ€å¤š 10 æ¬¡
                        let count = 0;
                        const poller = setInterval(async () => {
                            count++;
                            const r = await fetch('/outputs/');
                            const outputs = await r.json();
                            const target = outputs.find(o => o.id === id);
                            if (target && target.last_update_status && target.last_update_status.includes('+æ·±åº¦æ£€æµ‹å®Œæˆ')) {
                                showToast(`${target.name} æ·±åº¦æ£€æµ‹å·²åœ†æ»¡å®Œæˆï¼`, 'success');
                                fetchOutputs();
                                clearInterval(poller);
                            }
                            if (count >= 20) clearInterval(poller); // æœ€å¤šç­‰ä¸€åˆ†é’Ÿ
                        }, 3000);
                    }
                } else {
                    showToast('åˆ·æ–°è¯·æ±‚å¤±è´¥', 'error');
                }
            } catch (err) {
                showToast('ç½‘ç»œé”™è¯¯: ' + err.message, 'error');
            }
        }

        async function fetchOutputs(isSilence = false) {
            try {
                const res = await fetch('/outputs/');
                const data = await res.json();
                allOutputs = data; // å­˜å…¨å±€
                const list = document.getElementById('output_list');

                if (data.length === 0) {
                    list.innerHTML = 'æš‚æ— å·²åˆ›å»ºçš„èšåˆ';
                    return;
                }

                if (isSilence) {
                    // é™é»˜åˆ·æ–°ï¼šåªæ›´æ–°çŠ¶æ€æ–‡å­—å’Œæ—¶é—´ï¼Œä¸é‡ç»˜æ•´ä¸ªåˆ—è¡¨ä»¥é˜²é—ªçƒ
                    data.forEach(o => {
                        const card = document.querySelector(`.output-item-card[data-id="${o.id}"]`);
                        if (!card) return;

                        // æ›´æ–°æœ€ååŒæ­¥æ—¶é—´
                        const syncStatus = card.querySelector('.sync-status-text');
                        if (syncStatus) {
                            const statusColor = o.last_update_status && (o.last_update_status.includes('å¤±è´¥') || o.last_update_status.includes('Error')) ? '#ef4444' : '#10b981';
                            syncStatus.style.color = statusColor;
                            syncStatus.innerText = `æœ€ååŒæ­¥: ${formatDate(o.last_updated)} (${o.last_update_status || 'ç­‰å¾…æ›´æ–°'})`;
                        }

                        // æ›´æ–°å€’è®¡æ—¶ data å±æ€§ï¼Œé˜²æ­¢å¾ªç¯è§¦å‘
                        const timer = card.querySelector('.countdown-timer');
                        if (timer) {
                            timer.dataset.last = o.last_updated || '';
                        }
                    });
                    return;
                }

                list.innerHTML = data.map(o => {
                    const statusColor = o.last_update_status && (o.last_update_status.includes('å¤±è´¥') || o.last_update_status.includes('Error')) ? '#ef4444' : '#10b981';
                    const subIds = JSON.parse(o.subscription_ids || "[]");
                    // ... (ä¿æŒåŸæœ‰çš„ card HTML ç”Ÿæˆé€»è¾‘ä¸å˜) ...
                    let keywordsArr = [];
                    try { keywordsArr = JSON.parse(o.keywords || "[]"); } catch (e) { }

                    const tagsHtml = keywordsArr.map(k => {
                        const val = typeof k === 'string' ? k : k.value;
                        return `<span style="background: rgba(99,102,241,0.15); color: #a5b4fc; padding: 1px 6px; border-radius: 4px; font-size: 0.75em; border: 1px solid rgba(99,102,241,0.2);">${val}</span>`;
                    }).join(' ');

                    return `
                    <div class="output-item-card ${o.is_enabled === false ? 'disabled-card' : ''}">
                        <div class="card-info">
                            <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <strong style="font-size: 1.1em; color: var(--primary);">${o.name}</strong>
                                    ${o.is_enabled === false ? '<span style="font-size: 0.75em; background: #ef4444; color: #fff; padding: 2px 6px; border-radius: 4px;">å·²ç¦ç”¨</span>' : '<span style="font-size: 0.75em; background: #10b981; color: #fff; padding: 2px 6px; border-radius: 4px;">è¿è¡Œä¸­</span>'}
                                </div>
                                <div style="display: flex; gap: 5px;">
                                    ${o.auto_update_minutes > 0 ? `<span title="è‡ªåŠ¨åŒæ­¥å·²å¼€å¯" style="font-size: 1.1em;">ğŸ”„</span>` : ''}
                                    ${o.auto_visual_check ? `<span title="è‡ªåŠ¨æ·±åº¦æ£€æµ‹å·²å¼€å¯" style="font-size: 1.1em;">ğŸ“º</span>` : ''}
                                </div>
                            </div>
                            <div class="url-display" onclick="copyToClipboard('${window.location.origin}/m3u/${o.slug}')">
                                ${window.location.origin}/m3u/${o.slug}
                            </div>
                            <div style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px;">
                                ${tagsHtml || `<span style="opacity: 0.5; font-size: 0.8em;">(æ— ç­›é€‰è¯)</span>`}
                            </div>
                            <div style="font-size: 0.85em; opacity: 0.8; margin-top: 8px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                                <span style="color: #cbd5e1;">ğŸ“Š é¢‘é“: <strong>${o.total_count || 0}</strong> æ€»è®¡</span>
                                <span style="color: #10b981;">âœ… <strong>${o.enabled_count || 0}</strong> å¯ç”¨</span>
                                <span style="color: #ef4444;">âŒ <strong>${o.disabled_count || 0}</strong> ç¦ç”¨</span>
                                <span style="opacity: 0.6;">(æ¥æº: ${subIds.length})</span>
                            </div>
                            <div style="font-size: 0.85em; opacity: 0.7; margin-top: 6px; display: flex; align-items: center; gap: 10px;">
                                <span>æ­£åˆ™: <code>${o.filter_regex || '.*'}</code></span>
                                ${o.auto_update_minutes > 0 && o.is_enabled !== false ? `<span style="color: #a5b4fc;">â€¢ ğŸ”„ æ¯${o.auto_update_minutes >= 60 ? o.auto_update_minutes / 60 + 'æ—¶' : o.auto_update_minutes + 'åˆ†'}åŒæ­¥</span> <span id="countdown_${o.id}" class="countdown-timer" data-last="${o.last_updated}" data-interval="${o.auto_update_minutes}" style="color: #fbbf24; margin-left: 2px; font-size: 0.9em;"></span>` : ''}
                                ${o.auto_visual_check ? `<span style="color: #fbbf24;">â€¢ ğŸ“º è‡ªåŠ¨æ£€æµ‹</span>` : ''}
                            </div>
                            <div style="font-size: 0.8em; opacity: 0.5; margin-top: 6px;">
                                æœ€ååŒæ­¥: ${formatDate(o.last_updated)} ${o.last_update_status ? `(<span style="color: ${statusColor};">${o.last_update_status}</span>)` : ''}
                                <span style="margin-left: 12px;">ğŸ“¡ æœ€è¿‘è¯·æ±‚: ${formatDate(o.last_request_time)}</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 10px;">
                            <button class="btn btn-sm" style="background: var(--primary);" onclick="prepareEditOutput(${o.id})">ä¿®æ”¹</button>
                            <button class="btn btn-sm" style="background: ${o.is_enabled === false ? '#10b981' : '#64748b'};" onclick="toggleOutputStatus(${o.id}, ${o.is_enabled !== false})">
                                ${o.is_enabled === false ? 'å¯ç”¨' : 'ç¦ç”¨'}
                            </button>
                            <button class="btn btn-sm" style="background: #10b981;" onclick="refreshOutput(${o.id})">åˆ·æ–°æº</button>
                            <button class="btn btn-sm" style="background: #3b82f6;" onclick="viewOutputPreview('${o.slug}', '${o.name}')">é¢„è§ˆ</button>
                            <button class="btn btn-sm" style="background: #ef4444;" onclick="deleteOutput(${o.id})">åˆ é™¤</button>
                        </div>
                    </div>
                `}).join('');
            } catch (err) {
                console.error('è·å–èšåˆåˆ—è¡¨å¤±è´¥:', err);
            }
        }

        async function toggleOutputStatus(id, currentStatus) {
            const out = allOutputs.find(o => o.id === id);
            if (!out) return;

            const updated = {
                ...out,
                is_enabled: !currentStatus
            };

            try {
                const res = await fetch(`/outputs/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updated)
                });
                if (res.ok) {
                    showStatus(updated.is_enabled ? 'å·²å¯ç”¨èšåˆ' : 'å·²ç¦ç”¨èšåˆ');
                    fetchOutputs();
                } else {
                    const errData = await res.json();
                    alert('æ“ä½œå¤±è´¥: ' + (errData.detail || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (err) {
                alert('ç½‘ç»œé”™è¯¯: ' + err.message);
            }
        }

        async function copyToClipboard(text) {
            try {
                // å…ˆè¯•æ–°çš„ API
                if (navigator.clipboard) {
                    await navigator.clipboard.writeText(text);
                    showStatus('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    return;
                }
                throw new Error('Clipboard API unavailable');
            } catch (err) {
                // é™çº§æ–¹æ¡ˆ (HTTP è¿™ç§ä¸å®‰å…¨ç¯å¢ƒ)
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    textArea.style.position = "fixed";
                    textArea.style.left = "-9999px";
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ (Fallback)');
                } catch (fallbackErr) {
                    console.error('å¤åˆ¶å¤±è´¥:', fallbackErr);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶: ' + text);
                }
            }
        }

        function showStatus(msg) {
            const s = document.getElementById('status');
            if (!s) {
                showToast(msg, 'info'); // é™çº§åˆ° toast æç¤º
                return;
            }
            s.innerText = msg;
            s.style.display = 'block';
            s.style.background = '#6366f1';
            setTimeout(() => { if (s) s.style.display = 'none'; }, 3000);
        }

        // --- å¤šé€‰åŠç»Ÿè®¡é€»è¾‘ ---

        function toggleChannelSelection(id, isChecked) {
            id = parseInt(id); // ç¡®ä¿ ID ä¸ºæ•´æ•°

            // æ›´æ–°é€‰ä¸­çŠ¶æ€é›†åˆ
            if (isChecked) {
                window.selectedChannelIds.add(id);
            } else {
                window.selectedChannelIds.delete(id);
            }

            // åŒæ­¥æ‰€æœ‰ç›¸åŒ ID çš„å¤é€‰æ¡†åŠè¡Œæ ·å¼
            const duplicates = document.querySelectorAll(`.ch-checkbox[data-id="${id}"]`);
            duplicates.forEach(cb => {
                if (cb.checked !== isChecked) {
                    cb.checked = isChecked;
                }
                // æ›´æ–°è¡Œæ ·å¼
                const tr = cb.closest('tr');
                if (tr) {
                    if (isChecked) {
                        tr.classList.add('card-selected');
                    } else {
                        tr.classList.remove('card-selected');
                    }
                }
            });

            updatePreviewStats();
        }


        function handleCardClick(event, id) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ã€å¤é€‰æ¡†æˆ–é“¾æ¥ï¼Œåˆ™ä¸å¤„ç†ï¼Œé¿å…å†²çª
            if (event.target.closest('button') || event.target.closest('input') || event.target.closest('a')) {
                return;
            }

            const checkbox = document.querySelector(`.ch-checkbox[data-id="${id}"]`);
            if (checkbox) {
                const newState = !checkbox.checked;
                checkbox.checked = newState;
                toggleChannelSelection(id, newState);
                // toggleChannelSelection ä¼šå¤„ç†æ ·å¼æ›´æ–°
            }
        }

        function toggleSelectAll(checked) {
            if (checked) {
                // é€‰ä¸­å½“å‰è¿‡æ»¤åçš„æ‰€æœ‰é¢‘é“
                filteredChannels.forEach(c => window.selectedChannelIds.add(c.id));
            } else {
                // å–æ¶ˆå…¨é€‰
                window.selectedChannelIds.clear();
            }
            updateSelectionUI();
        }

        /**
         * åé€‰ï¼šé€‰ä¸­ç›®å‰æœªé€‰ä¸­çš„ï¼Œå–æ¶ˆé€‰ä¸­å·²é€‰ä¸­çš„ï¼ˆä»…é™å½“å‰è¿‡æ»¤ç»“æœï¼‰
         */

        function invertSelection() {
            const currentSet = new Set(window.selectedChannelIds);
            window.selectedChannelIds.clear();

            filteredChannels.forEach(c => {
                if (!currentSet.has(c.id)) {
                    window.selectedChannelIds.add(c.id);
                }
            });
            updateSelectionUI();
        }

        function updateSelectionUI() {
            // ç›´æ¥æ›´æ–° DOMï¼Œä¸é‡ç»˜å…¨è¡¨
            const checkboxes = document.querySelectorAll('.ch-checkbox');
            checkboxes.forEach(cb => {
                const id = parseInt(cb.dataset.id);
                if (!isNaN(id)) {
                    const isChecked = window.selectedChannelIds.has(id);
                    cb.checked = isChecked;

                    // æ›´æ–°æ¡Œé¢ç«¯è¡Œæ ·å¼
                    const tr = cb.closest('tr');
                    if (tr) {
                        if (isChecked) {
                            tr.classList.add('card-selected');
                        } else {
                            tr.classList.remove('card-selected');
                        }
                    }

                    // æ›´æ–°ç§»åŠ¨ç«¯å¡ç‰‡æ ·å¼
                    const card = cb.closest('.mobile-channel-card');
                    if (card) {
                        if (isChecked) {
                            card.classList.add('selected');
                        } else {
                            card.classList.remove('selected');
                        }
                    }
                }
            });
            updatePreviewStats();
        }

        function selectByStatus(enabled) {
            // æŠŠçŠ¶æ€å¯¹å¾—ä¸Šçš„éƒ½å‹¾ä¸Š
            filteredChannels.forEach(c => {
                const isEnabled = c.is_enabled !== false;
                if (isEnabled === enabled) {
                    window.selectedChannelIds.add(c.id);
                }
            });
            updateSelectionUI();
        }

        async function batchSetStatus(enable) {
            if (window.selectedChannelIds.size === 0) {
                alert("è¯·å…ˆå‹¾é€‰éœ€è¦æ“ä½œçš„é¢‘é“ï¼");
                return;
            }

            const actionName = enable ? "å¯ç”¨" : "ç¦ç”¨";
            const rowCount = filteredChannels.filter(c => window.selectedChannelIds.has(c.id)).length;
            if (!confirm(`ç¡®å®šè¦æ‰¹é‡ ${actionName} é€‰ä¸­çš„ ${rowCount} ä¸ªé¢‘é“å—ï¼Ÿ`)) return;

            const btnId = enable ? 'batch_enable_btn' : 'batch_disable_btn';
            const btn = document.getElementById(btnId);
            const originalText = btn ? btn.innerText : '';
            if (btn) btn.disabled = true;

            // ... (targets éƒ¨åˆ†çœç•¥ï¼Œé€»è¾‘ä¿æŒä¸å˜) ...

            let changedCount = 0;
            const total = window.selectedChannelIds.size;
            let index = 0;

            for (const id of window.selectedChannelIds) {
                index++;
                if (btn) btn.innerText = `å¤„ç†ä¸­ ${index}/${total}`;

                const c = currentChannels.find(ch => ch.id === id);
                if (c) {
                    const isEnabled = c.is_enabled !== false;
                    if (isEnabled !== enable) {
                        try {
                            // åˆ‡æ¢çŠ¶æ€
                            await fetch(`/channels/${id}/toggle`, { method: 'POST' });
                            c.is_enabled = enable; // å³æ—¶æ›´æ–°æœ¬åœ°æ•°æ®
                            changedCount++;
                        } catch (e) {
                            console.error(`Failed to toggle ${id}`, e);
                        }
                    }
                }
            }

            if (btn) {
                btn.innerText = originalText;
                btn.disabled = false;
            }

            // Update UI
            // ä¸å†é‡ç½® renderOffset å’Œç•Œé¢æ»šåŠ¨
            // éå†æ‰€æœ‰é€‰ä¸­çš„ ID å¹¶å±€éƒ¨æ›´æ–° DOM
            window.selectedChannelIds.forEach(id => {
                const toggleBtns = document.querySelectorAll(`button[onclick*="toggleChannel(${id})"]`);
                toggleBtns.forEach(btn => {
                    btn.innerText = enable ? 'ç¦ç”¨' : 'å¯ç”¨';
                    btn.style.background = enable ? '#ef4444' : '#10b981';
                    const tr = btn.closest('tr');
                    if (tr) {
                        tr.style.opacity = enable ? '1' : '0.5';
                        tr.style.background = enable ? 'transparent' : 'rgba(0,0,0,0.2)';
                    }
                });
            });

            updateSelectionUI(); // åˆ·ä¸‹å¤é€‰æ¡†å’Œç»Ÿè®¡æ¡†

            showToast(`æ‰¹é‡æ“ä½œå®Œæˆï¼Œå…±ä¿®æ”¹ ${changedCount} ä¸ªé¢‘é“`, 'success');
        }

        function updatePreviewStats() {
            const total = filteredChannels.length;
            const enabledCount = filteredChannels.filter(c => c.is_enabled !== false).length;
            const selected = filteredChannels.filter(c => window.selectedChannelIds.has(c.id)).length;

            const statsEl = document.getElementById('preview_stats');
            if (statsEl) {
                let html = `å…± ${total} ä¸ªé¢‘é“ / å·²å¯ç”¨ ${enabledCount} ä¸ª`;
                if (window.lastRenderShowActions) {
                    html += ` <span style="margin-left:10px; opacity:0.6;">(å·²é€‰ ${selected} ä¸ª)</span>`;
                }
                statsEl.innerHTML = html;
            }

            // æ›´æ–°å¤§å¤é€‰æ¡†çŠ¶æ€
            const master = document.getElementById('master_checkbox');
            if (master) {
                const allSelected = filteredChannels.length > 0 && filteredChannels.every(c => window.selectedChannelIds.has(c.id));
                master.checked = allSelected;
                master.indeterminate = selected > 0 && !allSelected;
            }
        }

        function updateCountdowns() {
            const timers = document.querySelectorAll('.countdown-timer');
            const now = new Date();

            timers.forEach(t => {
                const lastStr = t.dataset.last;
                const intervalMins = parseInt(t.dataset.interval);
                if (!lastStr || !intervalMins) return;

                // Comptaible parsing
                let dateStr = lastStr.replace(' ', 'T');
                if (!dateStr.endsWith('Z') && !dateStr.includes('+')) dateStr += 'Z';

                const last = new Date(dateStr);
                const next = new Date(last.getTime() + intervalMins * 60000);

                const diff = next - now;

                if (diff > 0) {
                    const hours = Math.floor(diff / 3600000);
                    const mins = Math.floor((diff % 3600000) / 60000);
                    const secs = Math.floor((diff % 60000) / 1000);

                    let text = `(${mins}åˆ†${secs}ç§’)`;
                    if (hours > 0) text = `(${hours}æ—¶${mins}åˆ†)`;

                    t.innerText = text;
                    t.style.opacity = '0.9';
                }
                if (diff <= 0) {
                    t.innerText = "(å‡†å¤‡æ›´æ–°...)";
                    t.style.color = "#fbbf24";
                    // å€’è®¡æ—¶ç»“æŸï¼Œé™é»˜æ‹‰å–ä¸€æ¬¡æœ€æ–°æ•°æ®ï¼Œå»¶è¿Ÿä¸€æ®µæ—¶é—´ç¡®ä¿åç«¯å·²å¤„ç†
                    if (!t.dataset.refreshing) {
                        t.dataset.refreshing = "true";
                        setTimeout(() => {
                            fetchOutputs(true).then(() => {
                                delete t.dataset.refreshing;
                            });
                        }, 5000);
                    }
                    return;
                }
            });
        }
        setInterval(updateCountdowns, 1000);

        fetchSubs();
        fetchOutputs();
    </script>
    <!-- å›¾ç‰‡é¢„è§ˆ Lightbox -->
    <div id="lightbox" class="lightbox" onclick="closeLightbox()">
        <span class="lightbox-close">&times;</span>
        <img class="lightbox-content" id="lightbox-img" onclick="event.stopPropagation()">
    </div>

    <script>
        function showLightbox(src) {
            const lightbox = document.getElementById('lightbox');
            const img = document.getElementById('lightbox-img');
            img.src = src;
            lightbox.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // é˜²æ­¢èƒŒæ™¯æ»šåŠ¨
        }

        function closeLightbox() {
            const lightbox = document.getElementById('lightbox');
            lightbox.style.display = 'none';
            document.body.style.overflow = '';
        }
    </script>
</body>

</html>